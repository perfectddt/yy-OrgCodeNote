{
    "sourceFile": "SplitTable.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 18,
            "patches": [
                {
                    "date": 1713513296855,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1713513302339,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,43 @@\n+import sqlite3\r\n+import os\r\n+import shutil\r\n+import argparse\r\n+\r\n+def split_table_into_multiple_dbs(original_table_name):\r\n+    # 连接到原始数据库\r\n+    conn = sqlite3.connect('yy_orgcodenote_my_database.db')\r\n+    cursor = conn.cursor()\r\n+\r\n+    # 查询所有不同的location值\r\n+    cursor.execute(f\"SELECT DISTINCT location FROM {original_table_name}\")\r\n+    locations = cursor.fetchall()\r\n+\r\n+    # 对每个location进行处理\r\n+    for location in locations:\r\n+        location = location[0]  # 获取元组中的location值\r\n+        file_name = os.path.basename(location)\r\n+        new_table_name = f\"{file_name}_table\"\r\n+\r\n+        # 创建新表\r\n+        cursor.execute(f\"CREATE TABLE {new_table_name} AS SELECT * FROM {original_table_name} WHERE location=?\", (location,))\r\n+\r\n+        # 创建新数据库文件\r\n+        new_db_path = os.path.join(location, 'yy_orgcodenote_my_database.db')\r\n+        shutil.copy('yy_orgcodenote_my_database.db', new_db_path)\r\n+\r\n+        # 提交更改并关闭原始数据库连接\r\n+        conn.commit()\r\n+\r\n+    # 关闭原始数据库连接\r\n+    conn.close()\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # 设置命令行参数解析\r\n+    parser = argparse.ArgumentParser(description='Split a table in a SQLite database into multiple databases based on location.')\r\n+    parser.add_argument('--table', '-t', type=str, required=True, help='The table name in the database.')\r\n+    \r\n+    # 解析命令行参数\r\n+    args = parser.parse_args()\r\n+\r\n+    # 调用函数，传入原始表名\r\n+    split_table_into_multiple_dbs(args.table)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713513309056,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -39,49 +39,5 @@\n     # 解析命令行参数\r\n     args = parser.parse_args()\r\n \r\n     # 调用函数，传入原始表名\r\n-    split_table_into_multiple_dbs(args.table)\n-\r\n-import sqlite3\r\n-import os\r\n-import shutil\r\n-import argparse\r\n-\r\n-def split_table_into_multiple_dbs(original_table_name):\r\n-    # 连接到原始数据库\r\n-    conn = sqlite3.connect('yy_orgcodenote_my_database.db')\r\n-    cursor = conn.cursor()\r\n-\r\n-    # 查询所有不同的location值\r\n-    cursor.execute(f\"SELECT DISTINCT location FROM {original_table_name}\")\r\n-    locations = cursor.fetchall()\r\n-\r\n-    # 对每个location进行处理\r\n-    for location in locations:\r\n-        location = location[0]  # 获取元组中的location值\r\n-        file_name = os.path.basename(location)\r\n-        new_table_name = f\"{file_name}_table\"\r\n-\r\n-        # 创建新表\r\n-        cursor.execute(f\"CREATE TABLE {new_table_name} AS SELECT * FROM {original_table_name} WHERE location=?\", (location,))\r\n-\r\n-        # 创建新数据库文件\r\n-        new_db_path = os.path.join(location, 'yy_orgcodenote_my_database.db')\r\n-        shutil.copy('yy_orgcodenote_my_database.db', new_db_path)\r\n-\r\n-        # 提交更改并关闭原始数据库连接\r\n-        conn.commit()\r\n-\r\n-    # 关闭原始数据库连接\r\n-    conn.close()\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # 设置命令行参数解析\r\n-    parser = argparse.ArgumentParser(description='Split a table in a SQLite database into multiple databases based on location.')\r\n-    parser.add_argument('--table', '-t', type=str, required=True, help='The table name in the database.')\r\n-    \r\n-    # 解析命令行参数\r\n-    args = parser.parse_args()\r\n-\r\n-    # 调用函数，传入原始表名\r\n     split_table_into_multiple_dbs(args.table)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713513872837,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,43 +0,0 @@\n-import sqlite3\r\n-import os\r\n-import shutil\r\n-import argparse\r\n-\r\n-def split_table_into_multiple_dbs(original_table_name):\r\n-    # 连接到原始数据库\r\n-    conn = sqlite3.connect('yy_orgcodenote_my_database.db')\r\n-    cursor = conn.cursor()\r\n-\r\n-    # 查询所有不同的location值\r\n-    cursor.execute(f\"SELECT DISTINCT location FROM {original_table_name}\")\r\n-    locations = cursor.fetchall()\r\n-\r\n-    # 对每个location进行处理\r\n-    for location in locations:\r\n-        location = location[0]  # 获取元组中的location值\r\n-        file_name = os.path.basename(location)\r\n-        new_table_name = f\"{file_name}_table\"\r\n-\r\n-        # 创建新表\r\n-        cursor.execute(f\"CREATE TABLE {new_table_name} AS SELECT * FROM {original_table_name} WHERE location=?\", (location,))\r\n-\r\n-        # 创建新数据库文件\r\n-        new_db_path = os.path.join(location, 'yy_orgcodenote_my_database.db')\r\n-        shutil.copy('yy_orgcodenote_my_database.db', new_db_path)\r\n-\r\n-        # 提交更改并关闭原始数据库连接\r\n-        conn.commit()\r\n-\r\n-    # 关闭原始数据库连接\r\n-    conn.close()\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # 设置命令行参数解析\r\n-    parser = argparse.ArgumentParser(description='Split a table in a SQLite database into multiple databases based on location.')\r\n-    parser.add_argument('--table', '-t', type=str, required=True, help='The table name in the database.')\r\n-    \r\n-    # 解析命令行参数\r\n-    args = parser.parse_args()\r\n-\r\n-    # 调用函数，传入原始表名\r\n-    split_table_into_multiple_dbs(args.table)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713513882313,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,47 @@\n+\r\n+import sqlite3\r\n+import os\r\n+import shutil\r\n+import argparse\r\n+\r\n+def split_table_into_multiple_dbs(original_table_name):\r\n+    # 连接到原始数据库\r\n+    conn = sqlite3.connect('yy_orgcodenote_my_database.db')\r\n+    cursor = conn.cursor()\r\n+\r\n+    # 使用方括号包裹表名以避免特殊字符问题\r\n+    wrapped_table_name = f'[{original_table_name}]'\r\n+    \r\n+    # 查询所有不同的location值\r\n+    cursor.execute(f\"SELECT DISTINCT location FROM {wrapped_table_name}\")\r\n+    locations = cursor.fetchall()\r\n+\r\n+    # 对每个location进行处理\r\n+    for location in locations:\r\n+        location = location[0]  # 获取元组中的location值\r\n+        file_name = os.path.basename(location)\r\n+        new_table_name = f\"{file_name}_table\"\r\n+\r\n+        # 创建新表\r\n+        cursor.execute(f\"CREATE TABLE {new_table_name} AS SELECT * FROM {wrapped_table_name} WHERE location=?\", (location,))\r\n+\r\n+        # 创建新数据库文件\r\n+        new_db_path = os.path.join(location, 'yy_orgcodenote_my_database.db')\r\n+        shutil.copy('yy_orgcodenote_my_database.db', new_db_path)\r\n+\r\n+        # 提交更改并关闭原始数据库连接\r\n+        conn.commit()\r\n+\r\n+    # 关闭原始数据库连接\r\n+    conn.close()\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # 设置命令行参数解析\r\n+    parser = argparse.ArgumentParser(description='Split a table in a SQLite database into multiple databases based on location.')\r\n+    parser.add_argument('--table', '-t', type=str, required=True, help='The table name in the database.')\r\n+    \r\n+    # 解析命令行参数\r\n+    args = parser.parse_args()\r\n+\r\n+    # 调用函数，传入原始表名\r\n+    split_table_into_multiple_dbs(args.table)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713514136841,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,4 @@\n-\r\n-import sqlite3\r\n import os\r\n import shutil\r\n import argparse\r\n \r\n"
                },
                {
                    "date": 1713514151514,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,6 @@\n+\r\n+import sqlite3\r\n import os\r\n import shutil\r\n import argparse\r\n \r\n@@ -19,18 +21,30 @@\n         location = location[0]  # 获取元组中的location值\r\n         file_name = os.path.basename(location)\r\n         new_table_name = f\"{file_name}_table\"\r\n \r\n-        # 创建新表\r\n+        # 在原始数据库中创建新表\r\n         cursor.execute(f\"CREATE TABLE {new_table_name} AS SELECT * FROM {wrapped_table_name} WHERE location=?\", (location,))\r\n+        conn.commit()\r\n \r\n         # 创建新数据库文件\r\n         new_db_path = os.path.join(location, 'yy_orgcodenote_my_database.db')\r\n         shutil.copy('yy_orgcodenote_my_database.db', new_db_path)\r\n \r\n-        # 提交更改并关闭原始数据库连接\r\n-        conn.commit()\r\n+        # 连接到新数据库\r\n+        new_conn = sqlite3.connect(new_db_path)\r\n+        new_cursor = new_conn.cursor()\r\n \r\n+        # 删除新数据库中除新表以外的所有表\r\n+        new_cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE ? AND name NOT LIKE 'sqlite_sequence'\", (new_table_name,))\r\n+        tables_to_drop = new_cursor.fetchall()\r\n+        for table in tables_to_drop:\r\n+            new_cursor.execute(f\"DROP TABLE {table[0]}\")\r\n+\r\n+        # 提交更改并关闭新数据库连接\r\n+        new_conn.commit()\r\n+        new_conn.close()\r\n+\r\n     # 关闭原始数据库连接\r\n     conn.close()\r\n \r\n if __name__ == \"__main__\":\r\n"
                },
                {
                    "date": 1713514159688,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,4 @@\n-\r\n import sqlite3\r\n import os\r\n import shutil\r\n import argparse\r\n"
                },
                {
                    "date": 1713514466309,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,58 +0,0 @@\n-import sqlite3\r\n-import os\r\n-import shutil\r\n-import argparse\r\n-\r\n-def split_table_into_multiple_dbs(original_table_name):\r\n-    # 连接到原始数据库\r\n-    conn = sqlite3.connect('yy_orgcodenote_my_database.db')\r\n-    cursor = conn.cursor()\r\n-\r\n-    # 使用方括号包裹表名以避免特殊字符问题\r\n-    wrapped_table_name = f'[{original_table_name}]'\r\n-    \r\n-    # 查询所有不同的location值\r\n-    cursor.execute(f\"SELECT DISTINCT location FROM {wrapped_table_name}\")\r\n-    locations = cursor.fetchall()\r\n-\r\n-    # 对每个location进行处理\r\n-    for location in locations:\r\n-        location = location[0]  # 获取元组中的location值\r\n-        file_name = os.path.basename(location)\r\n-        new_table_name = f\"{file_name}_table\"\r\n-\r\n-        # 在原始数据库中创建新表\r\n-        cursor.execute(f\"CREATE TABLE {new_table_name} AS SELECT * FROM {wrapped_table_name} WHERE location=?\", (location,))\r\n-        conn.commit()\r\n-\r\n-        # 创建新数据库文件\r\n-        new_db_path = os.path.join(location, 'yy_orgcodenote_my_database.db')\r\n-        shutil.copy('yy_orgcodenote_my_database.db', new_db_path)\r\n-\r\n-        # 连接到新数据库\r\n-        new_conn = sqlite3.connect(new_db_path)\r\n-        new_cursor = new_conn.cursor()\r\n-\r\n-        # 删除新数据库中除新表以外的所有表\r\n-        new_cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE ? AND name NOT LIKE 'sqlite_sequence'\", (new_table_name,))\r\n-        tables_to_drop = new_cursor.fetchall()\r\n-        for table in tables_to_drop:\r\n-            new_cursor.execute(f\"DROP TABLE {table[0]}\")\r\n-\r\n-        # 提交更改并关闭新数据库连接\r\n-        new_conn.commit()\r\n-        new_conn.close()\r\n-\r\n-    # 关闭原始数据库连接\r\n-    conn.close()\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # 设置命令行参数解析\r\n-    parser = argparse.ArgumentParser(description='Split a table in a SQLite database into multiple databases based on location.')\r\n-    parser.add_argument('--table', '-t', type=str, required=True, help='The table name in the database.')\r\n-    \r\n-    # 解析命令行参数\r\n-    args = parser.parse_args()\r\n-\r\n-    # 调用函数，传入原始表名\r\n-    split_table_into_multiple_dbs(args.table)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713514478323,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,71 @@\n+\r\n+import sqlite3\r\n+import os\r\n+import shutil\r\n+import argparse\r\n+\r\n+def split_table_into_multiple_dbs(database_path, original_table_name):\r\n+    # 确保数据库文件存在\r\n+    if not os.path.exists(database_path):\r\n+        print(f\"Error: Database file '{database_path}' does not exist.\")\r\n+        return\r\n+\r\n+    # 连接到原始数据库\r\n+    conn = sqlite3.connect(database_path)\r\n+    cursor = conn.cursor()\r\n+\r\n+    # 使用方括号包裹表名以避免特殊字符问题\r\n+    wrapped_table_name = f'[{original_table_name}]'\r\n+    \r\n+    # 检查原始表是否存在\r\n+    cursor.execute(f\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (wrapped_table_name,))\r\n+    if cursor.fetchone() is None:\r\n+        print(f\"Error: Table '{original_table_name}' does not exist in the database.\")\r\n+        return\r\n+\r\n+    # 查询所有不同的location值\r\n+    cursor.execute(f\"SELECT DISTINCT location FROM {wrapped_table_name}\")\r\n+    locations = cursor.fetchall()\r\n+\r\n+    # 对每个location进行处理\r\n+    for location in locations:\r\n+        location = location[0]  # 获取元组中的location值\r\n+        file_name = os.path.basename(location)\r\n+        new_table_name = f\"{file_name}_table\"\r\n+\r\n+        # 在原始数据库中创建新表\r\n+        cursor.execute(f\"CREATE TABLE {new_table_name} AS SELECT * FROM {wrapped_table_name} WHERE location=?\", (location,))\r\n+        conn.commit()\r\n+\r\n+        # 创建新数据库文件\r\n+        new_db_path = os.path.join(location, 'yy_orgcodenote_my_database.db')\r\n+        shutil.copy(database_path, new_db_path)\r\n+\r\n+        # 连接到新数据库\r\n+        new_conn = sqlite3.connect(new_db_path)\r\n+        new_cursor = new_conn.cursor()\r\n+\r\n+        # 删除新数据库中除新表以外的所有表\r\n+        new_cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE ? AND name NOT LIKE 'sqlite_sequence'\", (new_table_name,))\r\n+        tables_to_drop = new_cursor.fetchall()\r\n+        for table in tables_to_drop:\r\n+            new_cursor.execute(f\"DROP TABLE {table[0]}\")\r\n+\r\n+        # 提交更改并关闭新数据库连接\r\n+        new_conn.commit()\r\n+        new_conn.close()\r\n+\r\n+    # 关闭原始数据库连接\r\n+    conn.close()\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # 设置命令行参数解析\r\n+    parser = argparse.ArgumentParser(description='Split a table in a SQLite database into multiple databases based on location.')\r\n+    parser.add_argument('--database', '-d', type=str, required=True, help='The path to the SQLite database.')\r\n+    parser.add_argument('--table', '-t', type=str, required=True, help='The table name in the database.')\r\n+    \r\n+    # 解析命令行参数\r\n+    args = parser.parse_args()\r\n+\r\n+    # 调用函数，传入数据库路径和原始表名\r\n+    split_table_into_multiple_dbs(args.database, args.table)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713515033623,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,70 @@\n+import sqlite3\r\n+import os\r\n+import shutil\r\n+import argparse\r\n+\r\n+def split_table_into_multiple_dbs(database_path, original_table_name):\r\n+    # 确保数据库文件存在\r\n+    if not os.path.exists(database_path):\r\n+        print(f\"Error: Database file '{database_path}' does not exist.\")\r\n+        return\r\n+\r\n+    # 连接到原始数据库\r\n+    conn = sqlite3.connect(database_path)\r\n+    cursor = conn.cursor()\r\n+\r\n+    # 使用方括号包裹表名以避免特殊字符问题\r\n+    wrapped_table_name = f'[{original_table_name}]'\r\n+    \r\n+    # 检查原始表是否存在\r\n+    cursor.execute(f\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (wrapped_table_name,))\r\n+    if cursor.fetchone() is None:\r\n+        print(f\"Error: Table '{original_table_name}' does not exist in the database.\")\r\n+        return\r\n+\r\n+    # 查询所有不同的location值\r\n+    cursor.execute(f\"SELECT DISTINCT location FROM {wrapped_table_name}\")\r\n+    locations = cursor.fetchall()\r\n+\r\n+    # 对每个location进行处理\r\n+    for location in locations:\r\n+        location = location[0]  # 获取元组中的location值\r\n+        file_name = os.path.basename(location)\r\n+        new_table_name = f\"{file_name}_table\"\r\n+\r\n+        # 在原始数据库中创建新表\r\n+        cursor.execute(f\"CREATE TABLE {new_table_name} AS SELECT * FROM {wrapped_table_name} WHERE location=?\", (location,))\r\n+        conn.commit()\r\n+\r\n+        # 创建新数据库文件\r\n+        new_db_path = os.path.join(location, 'yy_orgcodenote_my_database.db')\r\n+        shutil.copy(database_path, new_db_path)\r\n+\r\n+        # 连接到新数据库\r\n+        new_conn = sqlite3.connect(new_db_path)\r\n+        new_cursor = new_conn.cursor()\r\n+\r\n+        # 删除新数据库中除新表以外的所有表\r\n+        new_cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE ? AND name NOT LIKE 'sqlite_sequence'\", (new_table_name,))\r\n+        tables_to_drop = new_cursor.fetchall()\r\n+        for table in tables_to_drop:\r\n+            new_cursor.execute(f\"DROP TABLE {table[0]}\")\r\n+\r\n+        # 提交更改并关闭新数据库连接\r\n+        new_conn.commit()\r\n+        new_conn.close()\r\n+\r\n+    # 关闭原始数据库连接\r\n+    conn.close()\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # 设置命令行参数解析\r\n+    parser = argparse.ArgumentParser(description='Split a table in a SQLite database into multiple databases based on location.')\r\n+    parser.add_argument('--database', '-d', type=str, required=True, help='The path to the SQLite database.')\r\n+    parser.add_argument('--table', '-t', type=str, required=True, help='The table name in the database.')\r\n+    \r\n+    # 解析命令行参数\r\n+    args = parser.parse_args()\r\n+\r\n+    # 调用函数，传入数据库路径和原始表名\r\n+    split_table_into_multiple_dbs(args.database, args.table)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713515221985,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,141 +0,0 @@\n-import sqlite3\r\n-import os\r\n-import shutil\r\n-import argparse\r\n-\r\n-def split_table_into_multiple_dbs(database_path, original_table_name):\r\n-    # 确保数据库文件存在\r\n-    if not os.path.exists(database_path):\r\n-        print(f\"Error: Database file '{database_path}' does not exist.\")\r\n-        return\r\n-\r\n-    # 连接到原始数据库\r\n-    conn = sqlite3.connect(database_path)\r\n-    cursor = conn.cursor()\r\n-\r\n-    # 使用方括号包裹表名以避免特殊字符问题\r\n-    wrapped_table_name = f'[{original_table_name}]'\r\n-    \r\n-    # 检查原始表是否存在\r\n-    cursor.execute(f\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (wrapped_table_name,))\r\n-    if cursor.fetchone() is None:\r\n-        print(f\"Error: Table '{original_table_name}' does not exist in the database.\")\r\n-        return\r\n-\r\n-    # 查询所有不同的location值\r\n-    cursor.execute(f\"SELECT DISTINCT location FROM {wrapped_table_name}\")\r\n-    locations = cursor.fetchall()\r\n-\r\n-    # 对每个location进行处理\r\n-    for location in locations:\r\n-        location = location[0]  # 获取元组中的location值\r\n-        file_name = os.path.basename(location)\r\n-        new_table_name = f\"{file_name}_table\"\r\n-\r\n-        # 在原始数据库中创建新表\r\n-        cursor.execute(f\"CREATE TABLE {new_table_name} AS SELECT * FROM {wrapped_table_name} WHERE location=?\", (location,))\r\n-        conn.commit()\r\n-\r\n-        # 创建新数据库文件\r\n-        new_db_path = os.path.join(location, 'yy_orgcodenote_my_database.db')\r\n-        shutil.copy(database_path, new_db_path)\r\n-\r\n-        # 连接到新数据库\r\n-        new_conn = sqlite3.connect(new_db_path)\r\n-        new_cursor = new_conn.cursor()\r\n-\r\n-        # 删除新数据库中除新表以外的所有表\r\n-        new_cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE ? AND name NOT LIKE 'sqlite_sequence'\", (new_table_name,))\r\n-        tables_to_drop = new_cursor.fetchall()\r\n-        for table in tables_to_drop:\r\n-            new_cursor.execute(f\"DROP TABLE {table[0]}\")\r\n-\r\n-        # 提交更改并关闭新数据库连接\r\n-        new_conn.commit()\r\n-        new_conn.close()\r\n-\r\n-    # 关闭原始数据库连接\r\n-    conn.close()\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # 设置命令行参数解析\r\n-    parser = argparse.ArgumentParser(description='Split a table in a SQLite database into multiple databases based on location.')\r\n-    parser.add_argument('--database', '-d', type=str, required=True, help='The path to the SQLite database.')\r\n-    parser.add_argument('--table', '-t', type=str, required=True, help='The table name in the database.')\r\n-    \r\n-    # 解析命令行参数\r\n-    args = parser.parse_args()\r\n-\r\n-    # 调用函数，传入数据库路径和原始表名\r\n-    split_table_into_multiple_dbs(args.database, args.table)\n-\r\n-import sqlite3\r\n-import os\r\n-import shutil\r\n-import argparse\r\n-\r\n-def split_table_into_multiple_dbs(database_path, original_table_name):\r\n-    # 确保数据库文件存在\r\n-    if not os.path.exists(database_path):\r\n-        print(f\"Error: Database file '{database_path}' does not exist.\")\r\n-        return\r\n-\r\n-    # 连接到原始数据库\r\n-    conn = sqlite3.connect(database_path)\r\n-    cursor = conn.cursor()\r\n-\r\n-    # 使用方括号包裹表名以避免特殊字符问题\r\n-    wrapped_table_name = f'[{original_table_name}]'\r\n-    \r\n-    # 检查原始表是否存在\r\n-    cursor.execute(f\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (wrapped_table_name,))\r\n-    if cursor.fetchone() is None:\r\n-        print(f\"Error: Table '{original_table_name}' does not exist in the database.\")\r\n-        return\r\n-\r\n-    # 查询所有不同的location值\r\n-    cursor.execute(f\"SELECT DISTINCT location FROM {wrapped_table_name}\")\r\n-    locations = cursor.fetchall()\r\n-\r\n-    # 对每个location进行处理\r\n-    for location in locations:\r\n-        location = location[0]  # 获取元组中的location值\r\n-        file_name = os.path.basename(location)\r\n-        new_table_name = f\"{file_name}_table\"\r\n-\r\n-        # 在原始数据库中创建新表\r\n-        cursor.execute(f\"CREATE TABLE {new_table_name} AS SELECT * FROM {wrapped_table_name} WHERE location=?\", (location,))\r\n-        conn.commit()\r\n-\r\n-        # 创建新数据库文件\r\n-        new_db_path = os.path.join(location, 'yy_orgcodenote_my_database.db')\r\n-        shutil.copy(database_path, new_db_path)\r\n-\r\n-        # 连接到新数据库\r\n-        new_conn = sqlite3.connect(new_db_path)\r\n-        new_cursor = new_conn.cursor()\r\n-\r\n-        # 删除新数据库中除新表以外的所有表\r\n-        new_cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE ? AND name NOT LIKE 'sqlite_sequence'\", (new_table_name,))\r\n-        tables_to_drop = new_cursor.fetchall()\r\n-        for table in tables_to_drop:\r\n-            new_cursor.execute(f\"DROP TABLE {table[0]}\")\r\n-\r\n-        # 提交更改并关闭新数据库连接\r\n-        new_conn.commit()\r\n-        new_conn.close()\r\n-\r\n-    # 关闭原始数据库连接\r\n-    conn.close()\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # 设置命令行参数解析\r\n-    parser = argparse.ArgumentParser(description='Split a table in a SQLite database into multiple databases based on location.')\r\n-    parser.add_argument('--database', '-d', type=str, required=True, help='The path to the SQLite database.')\r\n-    parser.add_argument('--table', '-t', type=str, required=True, help='The table name in the database.')\r\n-    \r\n-    # 解析命令行参数\r\n-    args = parser.parse_args()\r\n-\r\n-    # 调用函数，传入数据库路径和原始表名\r\n-    split_table_into_multiple_dbs(args.database, args.table)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713515227724,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,71 @@\n+\r\n+import sqlite3\r\n+import os\r\n+import shutil\r\n+import argparse\r\n+\r\n+def split_table_into_multiple_dbs(database_path, table_name):\r\n+    # 确保数据库文件存在\r\n+    if not os.path.exists(database_path):\r\n+        print(f\"Error: Database file '{database_path}' does not exist.\")\r\n+        return\r\n+\r\n+    # 连接到原始数据库\r\n+    conn = sqlite3.connect(database_path)\r\n+    cursor = conn.cursor()\r\n+\r\n+    # 使用方括号包裹表名以避免特殊字符问题\r\n+    wrapped_table_name = f'[{table_name}]'\r\n+    \r\n+    # 检查原始表是否存在\r\n+    cursor.execute(f\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (wrapped_table_name,))\r\n+    if cursor.fetchone() is None:\r\n+        print(f\"Error: Table '{table_name}' does not exist in the database.\")\r\n+        return\r\n+\r\n+    # 查询所有不同的location值\r\n+    cursor.execute(f\"SELECT DISTINCT location FROM {wrapped_table_name}\")\r\n+    locations = cursor.fetchall()\r\n+\r\n+    # 对每个location进行处理\r\n+    for location in locations:\r\n+        location = location[0]  # 获取元组中的location值\r\n+        file_name = os.path.basename(location)\r\n+        new_table_name = f\"{file_name}_table\"\r\n+\r\n+        # 在原始数据库中创建新表\r\n+        cursor.execute(f\"CREATE TABLE {new_table_name} AS SELECT * FROM {wrapped_table_name} WHERE location=?\", (location,))\r\n+        conn.commit()\r\n+\r\n+        # 创建新数据库文件\r\n+        new_db_path = os.path.join(location, 'yy_orgcodenote_my_database.db')\r\n+        shutil.copy(database_path, new_db_path)\r\n+\r\n+        # 连接到新数据库\r\n+        new_conn = sqlite3.connect(new_db_path)\r\n+        new_cursor = new_conn.cursor()\r\n+\r\n+        # 删除新数据库中除新表以外的所有表\r\n+        new_cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE ? AND name NOT LIKE 'sqlite_sequence'\", (new_table_name,))\r\n+        tables_to_drop = new_cursor.fetchall()\r\n+        for table in tables_to_drop:\r\n+            new_cursor.execute(f\"DROP TABLE {table[0]}\")\r\n+\r\n+        # 提交更改并关闭新数据库连接\r\n+        new_conn.commit()\r\n+        new_conn.close()\r\n+\r\n+    # 关闭原始数据库连接\r\n+    conn.close()\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # 设置命令行参数解析\r\n+    parser = argparse.ArgumentParser(description='Split a table in a SQLite database into multiple databases based on location.')\r\n+    parser.add_argument('--database', '-d', type=str, required=True, help='The path to the SQLite database.')\r\n+    parser.add_argument('--table', '-t', type=str, required=True, help='The table name in the database.')\r\n+    \r\n+    # 解析命令行参数\r\n+    args = parser.parse_args()\r\n+\r\n+    # 调用函数，传入数据库路径和原始表名\r\n+    split_table_into_multiple_dbs(args.database, args.table)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713515411866,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,71 @@\n+import sqlite3\r\n+import os\r\n+import shutil\r\n+import argparse\r\n+\r\n+def split_table_into_multiple_dbs(database_path, table_name):\r\n+    # 确保数据库文件存在\r\n+    if not os.path.exists(database_path):\r\n+        print(f\"Error: Database file '{database_path}' does not exist.\")\r\n+        return\r\n+\r\n+    # 连接到原始数据库\r\n+    conn = sqlite3.connect(database_path)\r\n+    cursor = conn.cursor()\r\n+\r\n+    # 使用方括号包裹表名以避免特殊字符问题\r\n+    wrapped_table_name = f'[{table_name}]'\r\n+    \r\n+    wrapped_table_name = f'[{table_name}]'\r\n+    # 检查原始表是否存在\r\n+    cursor.execute(f\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (wrapped_table_name,))\r\n+    if cursor.fetchone() is None:\r\n+        print(f\"Error: Table '{table_name}' does not exist in the database.\")\r\n+        return\r\n+\r\n+    # 查询所有不同的location值\r\n+    cursor.execute(f\"SELECT DISTINCT location FROM {wrapped_table_name}\")\r\n+    locations = cursor.fetchall()\r\n+\r\n+    # 对每个location进行处理\r\n+    for location in locations:\r\n+        location = location[0]  # 获取元组中的location值\r\n+        file_name = os.path.basename(location)\r\n+        new_table_name = f\"{file_name}_table\"\r\n+\r\n+        # 在原始数据库中创建新表\r\n+        cursor.execute(f\"CREATE TABLE {new_table_name} AS SELECT * FROM {wrapped_table_name} WHERE location=?\", (location,))\r\n+        conn.commit()\r\n+\r\n+        # 创建新数据库文件\r\n+        new_db_path = os.path.join(location, 'yy_orgcodenote_my_database.db')\r\n+        shutil.copy(database_path, new_db_path)\r\n+\r\n+        # 连接到新数据库\r\n+        new_conn = sqlite3.connect(new_db_path)\r\n+        new_cursor = new_conn.cursor()\r\n+\r\n+        # 删除新数据库中除新表以外的所有表\r\n+        new_cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE ? AND name NOT LIKE 'sqlite_sequence'\", (new_table_name,))\r\n+        tables_to_drop = new_cursor.fetchall()\r\n+        for table in tables_to_drop:\r\n+            new_cursor.execute(f\"DROP TABLE {table[0]}\")\r\n+\r\n+        # 提交更改并关闭新数据库连接\r\n+        new_conn.commit()\r\n+        new_conn.close()\r\n+\r\n+    # 关闭原始数据库连接\r\n+    conn.close()\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # 设置命令行参数解析\r\n+    parser = argparse.ArgumentParser(description='Split a table in a SQLite database into multiple databases based on location.')\r\n+    parser.add_argument('--database', '-d', type=str, required=True, help='The path to the SQLite database.')\r\n+    parser.add_argument('--table', '-t', type=str, required=True, help='The table name in the database.')\r\n+    \r\n+    # 解析命令行参数\r\n+    args = parser.parse_args()\r\n+\r\n+    # 调用函数，传入数据库路径和原始表名\r\n+    split_table_into_multiple_dbs(args.database, args.table)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713515417417,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,71 @@\n+import sqlite3\r\n+import os\r\n+import shutil\r\n+import argparse\r\n+\r\n+def split_table_into_multiple_dbs(database_path, table_name):\r\n+    # 确保数据库文件存在\r\n+    if not os.path.exists(database_path):\r\n+        print(f\"Error: Database file '{database_path}' does not exist.\")\r\n+        return\r\n+\r\n+    # 连接到原始数据库\r\n+    conn = sqlite3.connect(database_path)\r\n+    cursor = conn.cursor()\r\n+\r\n+    # 使用方括号包裹表名以避免特殊字符问题\r\n+    wrapped_table_name = f'[{table_name}]'\r\n+    wrapped_table_name = f'{table_name}]'\r\n+\r\n+    # 检查原始表是否存在\r\n+    cursor.execute(f\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (wrapped_table_name,))\r\n+    if cursor.fetchone() is None:\r\n+        print(f\"Error: Table '{table_name}' does not exist in the database.\")\r\n+        return\r\n+\r\n+    # 查询所有不同的location值\r\n+    cursor.execute(f\"SELECT DISTINCT location FROM {wrapped_table_name}\")\r\n+    locations = cursor.fetchall()\r\n+\r\n+    # 对每个location进行处理\r\n+    for location in locations:\r\n+        location = location[0]  # 获取元组中的location值\r\n+        file_name = os.path.basename(location)\r\n+        new_table_name = f\"{file_name}_table\"\r\n+\r\n+        # 在原始数据库中创建新表\r\n+        cursor.execute(f\"CREATE TABLE {new_table_name} AS SELECT * FROM {wrapped_table_name} WHERE location=?\", (location,))\r\n+        conn.commit()\r\n+\r\n+        # 创建新数据库文件\r\n+        new_db_path = os.path.join(location, 'yy_orgcodenote_my_database.db')\r\n+        shutil.copy(database_path, new_db_path)\r\n+\r\n+        # 连接到新数据库\r\n+        new_conn = sqlite3.connect(new_db_path)\r\n+        new_cursor = new_conn.cursor()\r\n+\r\n+        # 删除新数据库中除新表以外的所有表\r\n+        new_cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE ? AND name NOT LIKE 'sqlite_sequence'\", (new_table_name,))\r\n+        tables_to_drop = new_cursor.fetchall()\r\n+        for table in tables_to_drop:\r\n+            new_cursor.execute(f\"DROP TABLE {table[0]}\")\r\n+\r\n+        # 提交更改并关闭新数据库连接\r\n+        new_conn.commit()\r\n+        new_conn.close()\r\n+\r\n+    # 关闭原始数据库连接\r\n+    conn.close()\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # 设置命令行参数解析\r\n+    parser = argparse.ArgumentParser(description='Split a table in a SQLite database into multiple databases based on location.')\r\n+    parser.add_argument('--database', '-d', type=str, required=True, help='The path to the SQLite database.')\r\n+    parser.add_argument('--table', '-t', type=str, required=True, help='The table name in the database.')\r\n+    \r\n+    # 解析命令行参数\r\n+    args = parser.parse_args()\r\n+\r\n+    # 调用函数，传入数据库路径和原始表名\r\n+    split_table_into_multiple_dbs(args.database, args.table)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713515423158,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,10 +13,10 @@\n     conn = sqlite3.connect(database_path)\r\n     cursor = conn.cursor()\r\n \r\n     # 使用方括号包裹表名以避免特殊字符问题\r\n-    wrapped_table_name = f'[{table_name}]'\r\n-    wrapped_table_name = f'{table_name}]'\r\n+    # wrapped_table_name = f'[{table_name}]'\r\n+    wrapped_table_name = f'{table_name}'\r\n \r\n     # 检查原始表是否存在\r\n     cursor.execute(f\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (wrapped_table_name,))\r\n     if cursor.fetchone() is None:\r\n@@ -67,147 +67,5 @@\n     # 解析命令行参数\r\n     args = parser.parse_args()\r\n \r\n     # 调用函数，传入数据库路径和原始表名\r\n-    split_table_into_multiple_dbs(args.database, args.table)\n-import sqlite3\r\n-import os\r\n-import shutil\r\n-import argparse\r\n-\r\n-def split_table_into_multiple_dbs(database_path, table_name):\r\n-    # 确保数据库文件存在\r\n-    if not os.path.exists(database_path):\r\n-        print(f\"Error: Database file '{database_path}' does not exist.\")\r\n-        return\r\n-\r\n-    # 连接到原始数据库\r\n-    conn = sqlite3.connect(database_path)\r\n-    cursor = conn.cursor()\r\n-\r\n-    # 使用方括号包裹表名以避免特殊字符问题\r\n-    wrapped_table_name = f'[{table_name}]'\r\n-    \r\n-    wrapped_table_name = f'[{table_name}]'\r\n-    # 检查原始表是否存在\r\n-    cursor.execute(f\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (wrapped_table_name,))\r\n-    if cursor.fetchone() is None:\r\n-        print(f\"Error: Table '{table_name}' does not exist in the database.\")\r\n-        return\r\n-\r\n-    # 查询所有不同的location值\r\n-    cursor.execute(f\"SELECT DISTINCT location FROM {wrapped_table_name}\")\r\n-    locations = cursor.fetchall()\r\n-\r\n-    # 对每个location进行处理\r\n-    for location in locations:\r\n-        location = location[0]  # 获取元组中的location值\r\n-        file_name = os.path.basename(location)\r\n-        new_table_name = f\"{file_name}_table\"\r\n-\r\n-        # 在原始数据库中创建新表\r\n-        cursor.execute(f\"CREATE TABLE {new_table_name} AS SELECT * FROM {wrapped_table_name} WHERE location=?\", (location,))\r\n-        conn.commit()\r\n-\r\n-        # 创建新数据库文件\r\n-        new_db_path = os.path.join(location, 'yy_orgcodenote_my_database.db')\r\n-        shutil.copy(database_path, new_db_path)\r\n-\r\n-        # 连接到新数据库\r\n-        new_conn = sqlite3.connect(new_db_path)\r\n-        new_cursor = new_conn.cursor()\r\n-\r\n-        # 删除新数据库中除新表以外的所有表\r\n-        new_cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE ? AND name NOT LIKE 'sqlite_sequence'\", (new_table_name,))\r\n-        tables_to_drop = new_cursor.fetchall()\r\n-        for table in tables_to_drop:\r\n-            new_cursor.execute(f\"DROP TABLE {table[0]}\")\r\n-\r\n-        # 提交更改并关闭新数据库连接\r\n-        new_conn.commit()\r\n-        new_conn.close()\r\n-\r\n-    # 关闭原始数据库连接\r\n-    conn.close()\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # 设置命令行参数解析\r\n-    parser = argparse.ArgumentParser(description='Split a table in a SQLite database into multiple databases based on location.')\r\n-    parser.add_argument('--database', '-d', type=str, required=True, help='The path to the SQLite database.')\r\n-    parser.add_argument('--table', '-t', type=str, required=True, help='The table name in the database.')\r\n-    \r\n-    # 解析命令行参数\r\n-    args = parser.parse_args()\r\n-\r\n-    # 调用函数，传入数据库路径和原始表名\r\n-    split_table_into_multiple_dbs(args.database, args.table)\n-\r\n-import sqlite3\r\n-import os\r\n-import shutil\r\n-import argparse\r\n-\r\n-def split_table_into_multiple_dbs(database_path, table_name):\r\n-    # 确保数据库文件存在\r\n-    if not os.path.exists(database_path):\r\n-        print(f\"Error: Database file '{database_path}' does not exist.\")\r\n-        return\r\n-\r\n-    # 连接到原始数据库\r\n-    conn = sqlite3.connect(database_path)\r\n-    cursor = conn.cursor()\r\n-\r\n-    # 使用方括号包裹表名以避免特殊字符问题\r\n-    wrapped_table_name = f'[{table_name}]'\r\n-    \r\n-    # 检查原始表是否存在\r\n-    cursor.execute(f\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (wrapped_table_name,))\r\n-    if cursor.fetchone() is None:\r\n-        print(f\"Error: Table '{table_name}' does not exist in the database.\")\r\n-        return\r\n-\r\n-    # 查询所有不同的location值\r\n-    cursor.execute(f\"SELECT DISTINCT location FROM {wrapped_table_name}\")\r\n-    locations = cursor.fetchall()\r\n-\r\n-    # 对每个location进行处理\r\n-    for location in locations:\r\n-        location = location[0]  # 获取元组中的location值\r\n-        file_name = os.path.basename(location)\r\n-        new_table_name = f\"{file_name}_table\"\r\n-\r\n-        # 在原始数据库中创建新表\r\n-        cursor.execute(f\"CREATE TABLE {new_table_name} AS SELECT * FROM {wrapped_table_name} WHERE location=?\", (location,))\r\n-        conn.commit()\r\n-\r\n-        # 创建新数据库文件\r\n-        new_db_path = os.path.join(location, 'yy_orgcodenote_my_database.db')\r\n-        shutil.copy(database_path, new_db_path)\r\n-\r\n-        # 连接到新数据库\r\n-        new_conn = sqlite3.connect(new_db_path)\r\n-        new_cursor = new_conn.cursor()\r\n-\r\n-        # 删除新数据库中除新表以外的所有表\r\n-        new_cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE ? AND name NOT LIKE 'sqlite_sequence'\", (new_table_name,))\r\n-        tables_to_drop = new_cursor.fetchall()\r\n-        for table in tables_to_drop:\r\n-            new_cursor.execute(f\"DROP TABLE {table[0]}\")\r\n-\r\n-        # 提交更改并关闭新数据库连接\r\n-        new_conn.commit()\r\n-        new_conn.close()\r\n-\r\n-    # 关闭原始数据库连接\r\n-    conn.close()\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # 设置命令行参数解析\r\n-    parser = argparse.ArgumentParser(description='Split a table in a SQLite database into multiple databases based on location.')\r\n-    parser.add_argument('--database', '-d', type=str, required=True, help='The path to the SQLite database.')\r\n-    parser.add_argument('--table', '-t', type=str, required=True, help='The table name in the database.')\r\n-    \r\n-    # 解析命令行参数\r\n-    args = parser.parse_args()\r\n-\r\n-    # 调用函数，传入数据库路径和原始表名\r\n     split_table_into_multiple_dbs(args.database, args.table)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713515722826,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,71 @@\n+import sqlite3\r\n+import os\r\n+import shutil\r\n+import argparse\r\n+\r\n+def split_table_into_multiple_dbs(database_path, table_name):\r\n+    # 确保数据库文件存在\r\n+    if not os.path.exists(database_path):\r\n+        print(f\"Error: Database file '{database_path}' does not exist.\")\r\n+        return\r\n+\r\n+    # 连接到原始数据库\r\n+    conn = sqlite3.connect(database_path)\r\n+    cursor = conn.cursor()\r\n+\r\n+    # 使用方括号包裹表名以避免特殊字符问题\r\n+    # wrapped_table_name = f'[{table_name}]'\r\n+    wrapped_table_name = f'{table_name}'\r\n+\r\n+    # 检查原始表是否存在\r\n+    cursor.execute(f\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (wrapped_table_name,))\r\n+    if cursor.fetchone() is None:\r\n+        print(f\"Error: Table '{table_name}' does not exist in the database.\")\r\n+        return\r\n+\r\n+    # 查询所有不同的location值\r\n+    cursor.execute(f\"SELECT DISTINCT location FROM {wrapped_table_name}\")\r\n+    locations = cursor.fetchall()\r\n+\r\n+    # 对每个location进行处理\r\n+    for location in locations:\r\n+        location = location[0]  # 获取元组中的location值\r\n+        file_name = os.path.basename(location)\r\n+        new_table_name = f\"[]{file_name}_table\"\r\n+\r\n+        # 在原始数据库中创建新表\r\n+        cursor.execute(f\"CREATE TABLE {new_table_name} AS SELECT * FROM {wrapped_table_name} WHERE location=?\", (location,))\r\n+        conn.commit()\r\n+\r\n+        # 创建新数据库文件\r\n+        new_db_path = os.path.join(location, 'yy_orgcodenote_my_database.db')\r\n+        shutil.copy(database_path, new_db_path)\r\n+\r\n+        # 连接到新数据库\r\n+        new_conn = sqlite3.connect(new_db_path)\r\n+        new_cursor = new_conn.cursor()\r\n+\r\n+        # 删除新数据库中除新表以外的所有表\r\n+        new_cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE ? AND name NOT LIKE 'sqlite_sequence'\", (new_table_name,))\r\n+        tables_to_drop = new_cursor.fetchall()\r\n+        for table in tables_to_drop:\r\n+            new_cursor.execute(f\"DROP TABLE {table[0]}\")\r\n+\r\n+        # 提交更改并关闭新数据库连接\r\n+        new_conn.commit()\r\n+        new_conn.close()\r\n+\r\n+    # 关闭原始数据库连接\r\n+    conn.close()\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # 设置命令行参数解析\r\n+    parser = argparse.ArgumentParser(description='Split a table in a SQLite database into multiple databases based on location.')\r\n+    parser.add_argument('--database', '-d', type=str, required=True, help='The path to the SQLite database.')\r\n+    parser.add_argument('--table', '-t', type=str, required=True, help='The table name in the database.')\r\n+    \r\n+    # 解析命令行参数\r\n+    args = parser.parse_args()\r\n+\r\n+    # 调用函数，传入数据库路径和原始表名\r\n+    split_table_into_multiple_dbs(args.database, args.table)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713515728343,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,9 +30,9 @@\n     # 对每个location进行处理\r\n     for location in locations:\r\n         location = location[0]  # 获取元组中的location值\r\n         file_name = os.path.basename(location)\r\n-        new_table_name = f\"[{file_name}_table\"\r\n+        new_table_name = f\"[{file_name}_table]\"\r\n \r\n         # 在原始数据库中创建新表\r\n         cursor.execute(f\"CREATE TABLE {new_table_name} AS SELECT * FROM {wrapped_table_name} WHERE location=?\", (location,))\r\n         conn.commit()\r\n"
                },
                {
                    "date": 1713515860150,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,71 @@\n+import sqlite3\r\n+import os\r\n+import shutil\r\n+import argparse\r\n+\r\n+def split_table_into_multiple_dbs(database_path, table_name):\r\n+    # 确保数据库文件存在\r\n+    if not os.path.exists(database_path):\r\n+        print(f\"Error: Database file '{database_path}' does not exist.\")\r\n+        return\r\n+\r\n+    # 连接到原始数据库\r\n+    conn = sqlite3.connect(database_path)\r\n+    cursor = conn.cursor()\r\n+\r\n+    # 使用方括号包裹表名以避免特殊字符问题\r\n+    wrapped_table_name = f'[{table_name}]'\r\n+    wrapped_table_name = f'{table_name}'\r\n+\r\n+    # 检查原始表是否存在\r\n+    cursor.execute(f\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (wrapped_table_name,))\r\n+    if cursor.fetchone() is None:\r\n+        print(f\"Error: Table '{table_name}' does not exist in the database.\")\r\n+        return\r\n+\r\n+    # 查询所有不同的location值\r\n+    cursor.execute(f\"SELECT DISTINCT location FROM {wrapped_table_name}\")\r\n+    locations = cursor.fetchall()\r\n+\r\n+    # 对每个location进行处理\r\n+    for location in locations:\r\n+        location = location[0]  # 获取元组中的location值\r\n+        file_name = os.path.basename(location)\r\n+        new_table_name = f\"[{file_name}_table]\"\r\n+\r\n+        # 在原始数据库中创建新表\r\n+        cursor.execute(f\"CREATE TABLE {new_table_name} AS SELECT * FROM {wrapped_table_name} WHERE location=?\", (location,))\r\n+        conn.commit()\r\n+\r\n+        # 创建新数据库文件\r\n+        new_db_path = os.path.join(location, 'yy_orgcodenote_my_database.db')\r\n+        shutil.copy(database_path, new_db_path)\r\n+\r\n+        # 连接到新数据库\r\n+        new_conn = sqlite3.connect(new_db_path)\r\n+        new_cursor = new_conn.cursor()\r\n+\r\n+        # 删除新数据库中除新表以外的所有表\r\n+        new_cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE ? AND name NOT LIKE 'sqlite_sequence'\", (new_table_name,))\r\n+        tables_to_drop = new_cursor.fetchall()\r\n+        for table in tables_to_drop:\r\n+            new_cursor.execute(f\"DROP TABLE {table[0]}\")\r\n+\r\n+        # 提交更改并关闭新数据库连接\r\n+        new_conn.commit()\r\n+        new_conn.close()\r\n+\r\n+    # 关闭原始数据库连接\r\n+    conn.close()\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # 设置命令行参数解析\r\n+    parser = argparse.ArgumentParser(description='Split a table in a SQLite database into multiple databases based on location.')\r\n+    parser.add_argument('--database', '-d', type=str, required=True, help='The path to the SQLite database.')\r\n+    parser.add_argument('--table', '-t', type=str, required=True, help='The table name in the database.')\r\n+    \r\n+    # 解析命令行参数\r\n+    args = parser.parse_args()\r\n+\r\n+    # 调用函数，传入数据库路径和原始表名\r\n+    split_table_into_multiple_dbs(args.database, args.table)\n\\ No newline at end of file\n"
                }
            ],
            "date": 1713513296855,
            "name": "Commit-0",
            "content": "\r\nimport sqlite3\r\nimport os\r\nimport shutil\r\nimport argparse\r\n\r\ndef split_table_into_multiple_dbs(original_table_name):\r\n    # 连接到原始数据库\r\n    conn = sqlite3.connect('yy_orgcodenote_my_database.db')\r\n    cursor = conn.cursor()\r\n\r\n    # 查询所有不同的location值\r\n    cursor.execute(f\"SELECT DISTINCT location FROM {original_table_name}\")\r\n    locations = cursor.fetchall()\r\n\r\n    # 对每个location进行处理\r\n    for location in locations:\r\n        location = location[0]  # 获取元组中的location值\r\n        file_name = os.path.basename(location)\r\n        new_table_name = f\"{file_name}_table\"\r\n\r\n        # 创建新表\r\n        cursor.execute(f\"CREATE TABLE {new_table_name} AS SELECT * FROM {original_table_name} WHERE location=?\", (location,))\r\n\r\n        # 创建新数据库文件\r\n        new_db_path = os.path.join(location, 'yy_orgcodenote_my_database.db')\r\n        shutil.copy('yy_orgcodenote_my_database.db', new_db_path)\r\n\r\n        # 提交更改并关闭原始数据库连接\r\n        conn.commit()\r\n\r\n    # 关闭原始数据库连接\r\n    conn.close()\r\n\r\nif __name__ == \"__main__\":\r\n    # 设置命令行参数解析\r\n    parser = argparse.ArgumentParser(description='Split a table in a SQLite database into multiple databases based on location.')\r\n    parser.add_argument('--table', '-t', type=str, required=True, help='The table name in the database.')\r\n    \r\n    # 解析命令行参数\r\n    args = parser.parse_args()\r\n\r\n    # 调用函数，传入原始表名\r\n    split_table_into_multiple_dbs(args.table)"
        }
    ]
}