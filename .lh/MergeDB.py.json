{
    "sourceFile": "MergeDB.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 33,
            "patches": [
                {
                    "date": 1713518183172,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1713518520922,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,34 +0,0 @@\n-\r\n-import sqlite3\r\n-import os\r\n-import argparse\r\n-\r\n-def merge_databases(main_db_path, db_paths):\r\n-    # 连接到主数据库\r\n-    conn = sqlite3.connect(main_db_path)\r\n-    cursor = conn.cursor()\r\n-\r\n-    # 创建主数据库（如果它不存在）\r\n-    if not os.path.exists(main_db_path):\r\n-        with open(main_db_path, 'wb') as f:\r\n-            pass  # 创建空文件\r\n-\r\n-    # 添加所有数据库路径\r\n-    for db_path in db_paths:\r\n-        cursor.execute(f\"ATTACH DATABASE '{db_path}' AS {os.path.basename(db_path)}\")\r\n-\r\n-    # 提交更改并关闭连接\r\n-    conn.commit()\r\n-    conn.close()\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # 设置命令行参数解析\r\n-    parser = argparse.ArgumentParser(description='Merge multiple SQLite databases into one.')\r\n-    parser.add_argument('--main-db', '-m', type=str, required=True, help='The path to the main SQLite database.')\r\n-    parser.add_argument('--db-paths', '-p', nargs='+', type=str, required=True, help='The paths to the databases to be merged.')\r\n-    \r\n-    # 解析命令行参数\r\n-    args = parser.parse_args()\r\n-\r\n-    # 调用函数，传入主数据库路径和要合并的数据库路径\r\n-    merge_databases(args.main_db, args.db_paths)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713518530078,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,34 @@\n+\r\n+import sqlite3\r\n+import os\r\n+import argparse\r\n+\r\n+def merge_databases(main_db_path, db_paths):\r\n+    # 连接到主数据库\r\n+    conn = sqlite3.connect(main_db_path)\r\n+    cursor = conn.cursor()\r\n+\r\n+    # 创建主数据库（如果它不存在）\r\n+    if not os.path.exists(main_db_path):\r\n+        with open(main_db_path, 'wb') as f:\r\n+            pass  # 创建空文件\r\n+\r\n+    # 添加所有数据库路径\r\n+    for db_path in db_paths:\r\n+        cursor.execute(f\"ATTACH DATABASE '{db_path}' AS {os.path.basename(os.path.dirname(db_path))}\")\r\n+\r\n+    # 提交更改并关闭连接\r\n+    conn.commit()\r\n+    conn.close()\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # 设置命令行参数解析\r\n+    parser = argparse.ArgumentParser(description='Merge multiple SQLite databases into one.')\r\n+    parser.add_argument('--main-db', '-m', type=str, required=True, help='The path to the main SQLite database.')\r\n+    parser.add_argument('--db-paths', '-p', nargs='+', type=str, required=True, help='The paths to the databases to be merged.')\r\n+    \r\n+    # 解析命令行参数\r\n+    args = parser.parse_args()\r\n+\r\n+    # 调用函数，传入主数据库路径和要合并的数据库路径\r\n+    merge_databases(args.main_db, args.db_paths)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713518646820,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,34 +0,0 @@\n-\r\n-import sqlite3\r\n-import os\r\n-import argparse\r\n-\r\n-def merge_databases(main_db_path, db_paths):\r\n-    # 连接到主数据库\r\n-    conn = sqlite3.connect(main_db_path)\r\n-    cursor = conn.cursor()\r\n-\r\n-    # 创建主数据库（如果它不存在）\r\n-    if not os.path.exists(main_db_path):\r\n-        with open(main_db_path, 'wb') as f:\r\n-            pass  # 创建空文件\r\n-\r\n-    # 添加所有数据库路径\r\n-    for db_path in db_paths:\r\n-        cursor.execute(f\"ATTACH DATABASE '{db_path}' AS {os.path.basename(os.path.dirname(db_path))}\")\r\n-\r\n-    # 提交更改并关闭连接\r\n-    conn.commit()\r\n-    conn.close()\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # 设置命令行参数解析\r\n-    parser = argparse.ArgumentParser(description='Merge multiple SQLite databases into one.')\r\n-    parser.add_argument('--main-db', '-m', type=str, required=True, help='The path to the main SQLite database.')\r\n-    parser.add_argument('--db-paths', '-p', nargs='+', type=str, required=True, help='The paths to the databases to be merged.')\r\n-    \r\n-    # 解析命令行参数\r\n-    args = parser.parse_args()\r\n-\r\n-    # 调用函数，传入主数据库路径和要合并的数据库路径\r\n-    merge_databases(args.main_db, args.db_paths)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713518661815,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,34 @@\n+\r\n+import sqlite3\r\n+import os\r\n+import argparse\r\n+\r\n+def merge_databases(main_db_path, db_paths):\r\n+    # 连接到主数据库\r\n+    conn = sqlite3.connect(main_db_path)\r\n+    cursor = conn.cursor()\r\n+\r\n+    # 创建主数据库（如果它不存在）\r\n+    if not os.path.exists(main_db_path):\r\n+        with open(main_db_path, 'wb') as f:\r\n+            pass  # 创建空文件\r\n+\r\n+    # 添加所有数据库路径\r\n+    for db_path in db_paths:\r\n+        cursor.execute(f\"ATTACH DATABASE '{db_path}' AS {os.path.basename(os.path.dirname(db_path))}\")\r\n+\r\n+    # 提交更改并关闭连接\r\n+    conn.commit()\r\n+    conn.close()\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # 设置命令行参数解析\r\n+    parser = argparse.ArgumentParser(description='Merge multiple SQLite databases into one.')\r\n+    parser.add_argument('--main-db', '-m', type=str, required=True, help='The path to the main SQLite database.')\r\n+    parser.add_argument('--db-paths', '-p', nargs='+', type=str, required=True, help='The paths to the databases to be merged.')\r\n+    \r\n+    # 解析命令行参数\r\n+    args = parser.parse_args()\r\n+\r\n+    # 调用函数，传入主数据库路径和要合并的数据库路径\r\n+    merge_databases(args.main_db, args.db_paths)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713518866387,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,34 +0,0 @@\n-\r\n-import sqlite3\r\n-import os\r\n-import argparse\r\n-\r\n-def merge_databases(main_db_path, db_paths):\r\n-    # 连接到主数据库\r\n-    conn = sqlite3.connect(main_db_path)\r\n-    cursor = conn.cursor()\r\n-\r\n-    # 创建主数据库（如果它不存在）\r\n-    if not os.path.exists(main_db_path):\r\n-        with open(main_db_path, 'wb') as f:\r\n-            pass  # 创建空文件\r\n-\r\n-    # 添加所有数据库路径\r\n-    for db_path in db_paths:\r\n-        cursor.execute(f\"ATTACH DATABASE '{db_path}' AS {os.path.basename(os.path.dirname(db_path))}\")\r\n-\r\n-    # 提交更改并关闭连接\r\n-    conn.commit()\r\n-    conn.close()\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # 设置命令行参数解析\r\n-    parser = argparse.ArgumentParser(description='Merge multiple SQLite databases into one.')\r\n-    parser.add_argument('--main-db', '-m', type=str, required=True, help='The path to the main SQLite database.')\r\n-    parser.add_argument('--db-paths', '-p', nargs='+', type=str, required=True, help='The paths to the databases to be merged.')\r\n-    \r\n-    # 解析命令行参数\r\n-    args = parser.parse_args()\r\n-\r\n-    # 调用函数，传入主数据库路径和要合并的数据库路径\r\n-    merge_databases(args.main_db, args.db_paths)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713518879496,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,41 @@\n+\r\n+import sqlite3\r\n+import os\r\n+import argparse\r\n+\r\n+def merge_databases(main_db_path, db_paths):\r\n+    # 连接到主数据库\r\n+    conn = sqlite3.connect(main_db_path)\r\n+    cursor = conn.cursor()\r\n+\r\n+    # 创建主数据库（如果它不存在）\r\n+    if not os.path.exists(main_db_path):\r\n+        with open(main_db_path, 'wb') as f:\r\n+            pass  # 创建空文件\r\n+\r\n+    # 添加所有数据库路径\r\n+    for db_path in db_paths:\r\n+        cursor.execute(f\"ATTACH DATABASE '{db_path}' AS {os.path.basename(db_path)}\")\r\n+\r\n+    # 复制所有表到主数据库\r\n+    for db_name in cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\"):\r\n+        db_name = db_name[0]\r\n+        cursor.execute(f\"SELECT sql FROM sqlite_master WHERE type='table' AND name='{db_name}'\")\r\n+        table_sql = cursor.fetchone()[0]\r\n+        cursor.execute(f\"CREATE TABLE {db_name} AS {table_sql}\")\r\n+\r\n+    # 提交更改并关闭连接\r\n+    conn.commit()\r\n+    conn.close()\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # 设置命令行参数解析\r\n+    parser = argparse.ArgumentParser(description='Merge multiple SQLite databases into one.')\r\n+    parser.add_argument('--main-db', '-m', type=str, required=True, help='The path to the main SQLite database.')\r\n+    parser.add_argument('--db-paths', '-p', nargs='+', type=str, required=True, help='The paths to the databases to be merged.')\r\n+    \r\n+    # 解析命令行参数\r\n+    args = parser.parse_args()\r\n+\r\n+    # 调用函数，传入主数据库路径和要合并的数据库路径\r\n+    merge_databases(args.main_db, args.db_paths)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713521534982,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,40 +0,0 @@\n-import sqlite3\r\n-import os\r\n-import argparse\r\n-\r\n-def merge_databases(main_db_path, db_paths):\r\n-    # 连接到主数据库\r\n-    conn = sqlite3.connect(main_db_path)\r\n-    cursor = conn.cursor()\r\n-\r\n-    # 创建主数据库（如果它不存在）\r\n-    if not os.path.exists(main_db_path):\r\n-        with open(main_db_path, 'wb') as f:\r\n-            pass  # 创建空文件\r\n-\r\n-    # 添加所有数据库路径\r\n-    for db_path in db_paths:\r\n-        cursor.execute(f\"ATTACH DATABASE '{db_path}' AS {os.path.basename(db_path)}\")\r\n-\r\n-    # 复制所有表到主数据库\r\n-    for db_name in cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\"):\r\n-        db_name = db_name[0]\r\n-        cursor.execute(f\"SELECT sql FROM sqlite_master WHERE type='table' AND name='{db_name}'\")\r\n-        table_sql = cursor.fetchone()[0]\r\n-        cursor.execute(f\"CREATE TABLE {db_name} AS {table_sql}\")\r\n-\r\n-    # 提交更改并关闭连接\r\n-    conn.commit()\r\n-    conn.close()\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # 设置命令行参数解析\r\n-    parser = argparse.ArgumentParser(description='Merge multiple SQLite databases into one.')\r\n-    parser.add_argument('--main-db', '-m', type=str, required=True, help='The path to the main SQLite database.')\r\n-    parser.add_argument('--db-paths', '-p', nargs='+', type=str, required=True, help='The paths to the databases to be merged.')\r\n-    \r\n-    # 解析命令行参数\r\n-    args = parser.parse_args()\r\n-\r\n-    # 调用函数，传入主数据库路径和要合并的数据库路径\r\n-    merge_databases(args.main_db, args.db_paths)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713521543868,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,1 +1,47 @@\n \r\n+import sqlite3\r\n+import os\r\n+import argparse\r\n+\r\n+def merge_databases(main_db_path, db_paths):\r\n+    # 连接到主数据库\r\n+    conn = sqlite3.connect(main_db_path)\r\n+    cursor = conn.cursor()\r\n+\r\n+    # 创建主数据库（如果它不存在）\r\n+    if not os.path.exists(main_db_path):\r\n+        with open(main_db_path, 'wb') as f:\r\n+            pass  # 创建空文件\r\n+\r\n+    # 添加所有数据库路径\r\n+    for db_path in db_paths:\r\n+        cursor.execute(f\"ATTACH DATABASE '{db_path}' AS {os.path.basename(db_path)}\")\r\n+\r\n+    # 复制所有表到主数据库\r\n+    for db_name in cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\"):\r\n+        db_name = db_name[0]\r\n+        cursor.execute(f\"SELECT sql FROM sqlite_master WHERE type='table' AND name='{db_name}'\")\r\n+        table_sql = cursor.fetchone()[0]\r\n+        \r\n+        # 如果主数据库中没有这个表，则创建它\r\n+        if not cursor.execute(f\"SELECT name FROM sqlite_master WHERE type='table' AND name='{db_name}'\").fetchone():\r\n+            cursor.execute(f\"CREATE TABLE {db_name} AS {table_sql}\")\r\n+        else:\r\n+            # 如果主数据库中已经存在这个表，则合并数据\r\n+            cursor.execute(f\"INSERT INTO {db_name} SELECT * FROM {db_name}@{os.path.basename(db_path)}\")\r\n+\r\n+    # 提交更改并关闭连接\r\n+    conn.commit()\r\n+    conn.close()\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # 设置命令行参数解析\r\n+    parser = argparse.ArgumentParser(description='Merge multiple SQLite databases into one.')\r\n+    parser.add_argument('--main-db', '-m', type=str, required=True, help='The path to the main SQLite database.')\r\n+    parser.add_argument('--db-paths', '-p', nargs='+', type=str, required=True, help='The paths to the databases to be merged.')\r\n+    \r\n+    # 解析命令行参数\r\n+    args = parser.parse_args()\r\n+\r\n+    # 调用函数，传入主数据库路径和要合并的数据库路径\r\n+    merge_databases(args.main_db, args.db_paths)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713521704562,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,47 +0,0 @@\n-\r\n-import sqlite3\r\n-import os\r\n-import argparse\r\n-\r\n-def merge_databases(main_db_path, db_paths):\r\n-    # 连接到主数据库\r\n-    conn = sqlite3.connect(main_db_path)\r\n-    cursor = conn.cursor()\r\n-\r\n-    # 创建主数据库（如果它不存在）\r\n-    if not os.path.exists(main_db_path):\r\n-        with open(main_db_path, 'wb') as f:\r\n-            pass  # 创建空文件\r\n-\r\n-    # 添加所有数据库路径\r\n-    for db_path in db_paths:\r\n-        cursor.execute(f\"ATTACH DATABASE '{db_path}' AS {os.path.basename(db_path)}\")\r\n-\r\n-    # 复制所有表到主数据库\r\n-    for db_name in cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\"):\r\n-        db_name = db_name[0]\r\n-        cursor.execute(f\"SELECT sql FROM sqlite_master WHERE type='table' AND name='{db_name}'\")\r\n-        table_sql = cursor.fetchone()[0]\r\n-        \r\n-        # 如果主数据库中没有这个表，则创建它\r\n-        if not cursor.execute(f\"SELECT name FROM sqlite_master WHERE type='table' AND name='{db_name}'\").fetchone():\r\n-            cursor.execute(f\"CREATE TABLE {db_name} AS {table_sql}\")\r\n-        else:\r\n-            # 如果主数据库中已经存在这个表，则合并数据\r\n-            cursor.execute(f\"INSERT INTO {db_name} SELECT * FROM {db_name}@{os.path.basename(db_path)}\")\r\n-\r\n-    # 提交更改并关闭连接\r\n-    conn.commit()\r\n-    conn.close()\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # 设置命令行参数解析\r\n-    parser = argparse.ArgumentParser(description='Merge multiple SQLite databases into one.')\r\n-    parser.add_argument('--main-db', '-m', type=str, required=True, help='The path to the main SQLite database.')\r\n-    parser.add_argument('--db-paths', '-p', nargs='+', type=str, required=True, help='The paths to the databases to be merged.')\r\n-    \r\n-    # 解析命令行参数\r\n-    args = parser.parse_args()\r\n-\r\n-    # 调用函数，传入主数据库路径和要合并的数据库路径\r\n-    merge_databases(args.main_db, args.db_paths)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713521739251,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,74 @@\n+import sqlite3\r\n+import os\r\n+import shutil\r\n+import argparse\r\n+\r\n+def split_table_into_multiple_dbs(database_path, table_name):\r\n+    # 确保数据库文件存在\r\n+    if not os.path.exists(database_path):\r\n+        print(f\"Error: Database file '{database_path}' does not exist.\")\r\n+        return\r\n+\r\n+    # 连接到原始数据库\r\n+    conn = sqlite3.connect(database_path)\r\n+    cursor = conn.cursor()\r\n+\r\n+    # 使用方括号包裹表名以避免特殊字符问题\r\n+    wrapped_table_name = f'[{table_name}]'\r\n+    \r\n+    # 检查原始表是否存在\r\n+    cursor.execute(f\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (wrapped_table_name,))\r\n+    if cursor.fetchone() is None:\r\n+        print(f\"Error: Table '{table_name}' does not exist in the database.\")\r\n+        return\r\n+\r\n+    # 查询所有不同的location值\r\n+    cursor.execute(f\"SELECT DISTINCT location FROM {wrapped_table_name}\")\r\n+    locations = cursor.fetchall()\r\n+\r\n+    # 对每个location进行处理\r\n+    for location in locations:\r\n+        location = location[0]  # 获取元组中的location值\r\n+        file_name = os.path.basename(location)\r\n+        new_table_name = f\"{file_name}_table\"\r\n+\r\n+        # 尝试创建新表，如果已存在则跳过\r\n+        try:\r\n+            cursor.execute(f\"CREATE TABLE IF NOT EXISTS {new_table_name} AS SELECT * FROM {wrapped_table_name} WHERE location=?\", (location,))\r\n+        except sqlite3.OperationalError as e:\r\n+            print(f\"Error creating table {new_table_name}: {e}\")\r\n+            continue\r\n+\r\n+        # 创建新数据库文件\r\n+        new_db_path = os.path.join(location, 'yy_orgcodenote_my_database.db')\r\n+        if not os.path.exists(new_db_path):\r\n+            with open(new_db_path, 'wb') as f:\r\n+                pass  # 创建空文件\r\n+\r\n+        # 连接到新数据库\r\n+        new_conn = sqlite3.connect(new_db_path)\r\n+        new_cursor = new_conn.cursor()\r\n+\r\n+        # 删除新数据库中除新表以外的所有表\r\n+        new_cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE ? AND name NOT LIKE 'sqlite_sequence'\", (new_table_name,))\r\n+        tables_to_drop = new_cursor.fetchall()\r\n+        for table in tables_to_drop:\r\n+            new_cursor.execute(f\"DROP TABLE {table[0]}\")\r\n+\r\n+        # 提交更改并关闭新数据库连接\r\n+        new_conn.commit()\r\n+        new_conn.close()\r\n+\r\n+    # 关闭原始数据库连接\r\n+    conn.close()\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # 设置命令行参数解析\r\n+    parser = argparse.ArgumentParser(description='Split a table in a SQLite database into multiple databases based on location.')\r\n+    parser.add_argument('--database', '-d', type=str, required=True, help='The path to the SQLite database.')\r\n+    parser.add_argument('--table', '-t', type=str, required=True, help='The table name in the database.')\r\n+    \r\n+    # 解析命令行参数\r\n+    args = parser.parse_args()\r\n+\r\n+    # 调用函数\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713521753037,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,77 @@\n+import sqlite3\r\n+import os\r\n+import shutil\r\n+import argparse\r\n+\r\n+def split_table_into_multiple_dbs(database_path, table_name):\r\n+    # 确保数据库文件存在\r\n+    if not os.path.exists(database_path):\r\n+        print(f\"Error: Database file '{database_path}' does not exist.\")\r\n+        return\r\n+\r\n+    # 连接到原始数据库\r\n+    conn = sqlite3.connect(database_path)\r\n+    cursor = conn.cursor()\r\n+\r\n+    # 使用方括号包裹表名以避免特殊字符问题\r\n+    wrapped_table_name = f'[{table_name}]'\r\n+    \r\n+    # 检查原始表是否存在\r\n+    cursor.execute(f\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (wrapped_table_name,))\r\n+    if cursor.fetchone() is None:\r\n+        print(f\"Error: Table '{table_name}' does not exist in the database.\")\r\n+        return\r\n+\r\n+    # 查询所有不同的location值\r\n+    cursor.execute(f\"SELECT DISTINCT location FROM {wrapped_table_name}\")\r\n+    locations = cursor.fetchall()\r\n+\r\n+    # 对每个location进行处理\r\n+    for location in locations:\r\n+        location = location[0]  # 获取元组中的location值\r\n+        file_name = os.path.basename(location)\r\n+        new_table_name = f\"{file_name}_table\"\r\n+\r\n+        # 尝试创建新表，如果已存在则跳过\r\n+        try:\r\n+            cursor.execute(f\"CREATE TABLE IF NOT EXISTS {new_table_name} AS SELECT * FROM {wrapped_table_name} WHERE location=?\", (location,))\r\n+        except sqlite3.OperationalError as e:\r\n+            print(f\"Error creating table {new_table_name}: {e}\")\r\n+            continue\r\n+\r\n+        # 创建新数据库文件\r\n+        new_db_path = os.path.join(location, 'yy_orgcodenote_my_database.db')\r\n+        if not os.path.exists(new_db_path):\r\n+            with open(new_db_path, 'wb') as f:\r\n+                pass  # 创建空文件\r\n+\r\n+        # 连接到新数据库\r\n+        new_conn = sqlite3.connect(new_db_path)\r\n+        new_cursor = new_conn.cursor()\r\n+\r\n+        # 删除新数据库中除新表以外的所有表\r\n+        new_cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE ? AND name NOT LIKE 'sqlite_sequence'\", (new_table_name,))\r\n+        tables_to_drop = new_cursor.fetchall()\r\n+        for table in tables_to_drop:\r\n+            new_cursor.execute(f\"DROP TABLE {table[0]}\")\r\n+\r\n+        # 提交更改并关闭新数据库连接\r\n+        new_conn.commit()\r\n+        new_conn.close()\r\n+\r\n+    # 关闭原始数据库连接\r\n+    conn.close()\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # 设置命令行参数解析\r\n+    parser = argparse.ArgumentParser(description='Split a table in a SQLite database into multiple databases based on location.')\r\n+    parser.add_argument('--database', '-d', type=str, required=True, help='The path to the SQLite database.')\r\n+    parser.add_argument('--table', '-t', type=str, required=True, help='The table name in the database.')\r\n+    \r\n+    # 解析命令行参数\r\n+    args = parser.parse_args()\r\n+\r\n+    # 调用函数\r\n+    #\r\n+    # 调用函数，传入数据库路径和原始表名\r\n+    split_table_into_multiple_dbs(args.database, args.table)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713521758863,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,76 @@\n+import sqlite3\r\n+import os\r\n+import shutil\r\n+import argparse\r\n+\r\n+def split_table_into_multiple_dbs(database_path, table_name):\r\n+    # 确保数据库文件存在\r\n+    if not os.path.exists(database_path):\r\n+        print(f\"Error: Database file '{database_path}' does not exist.\")\r\n+        return\r\n+\r\n+    # 连接到原始数据库\r\n+    conn = sqlite3.connect(database_path)\r\n+    cursor = conn.cursor()\r\n+\r\n+    # 使用方括号包裹表名以避免特殊字符问题\r\n+    wrapped_table_name = f'[{table_name}]'\r\n+    \r\n+    # 检查原始表是否存在\r\n+    cursor.execute(f\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (wrapped_table_name,))\r\n+    if cursor.fetchone() is None:\r\n+        print(f\"Error: Table '{table_name}' does not exist in the database.\")\r\n+        return\r\n+\r\n+    # 查询所有不同的location值\r\n+    cursor.execute(f\"SELECT DISTINCT location FROM {wrapped_table_name}\")\r\n+    locations = cursor.fetchall()\r\n+\r\n+    # 对每个location进行处理\r\n+    for location in locations:\r\n+        location = location[0]  # 获取元组中的location值\r\n+        file_name = os.path.basename(location)\r\n+        new_table_name = f\"{file_name}_table\"\r\n+\r\n+        # 尝试创建新表，如果已存在则跳过\r\n+        try:\r\n+            cursor.execute(f\"CREATE TABLE IF NOT EXISTS {new_table_name} AS SELECT * FROM {wrapped_table_name} WHERE location=?\", (location,))\r\n+        except sqlite3.OperationalError as e:\r\n+            print(f\"Error creating table {new_table_name}: {e}\")\r\n+            continue\r\n+\r\n+        # 创建新数据库文件\r\n+        new_db_path = os.path.join(location, 'yy_orgcodenote_my_database.db')\r\n+        if not os.path.exists(new_db_path):\r\n+            with open(new_db_path, 'wb') as f:\r\n+                pass  # 创建空文件\r\n+\r\n+        # 连接到新数据库\r\n+        new_conn = sqlite3.connect(new_db_path)\r\n+        new_cursor = new_conn.cursor()\r\n+\r\n+        # 删除新数据库中除新表以外的所有表\r\n+        new_cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE ? AND name NOT LIKE 'sqlite_sequence'\", (new_table_name,))\r\n+        tables_to_drop = new_cursor.fetchall()\r\n+        for table in tables_to_drop:\r\n+            new_cursor.execute(f\"DROP TABLE {table[0]}\")\r\n+\r\n+        # 提交更改并关闭新数据库连接\r\n+        new_conn.commit()\r\n+        new_conn.close()\r\n+\r\n+    # 关闭原始数据库连接\r\n+    conn.close()\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # 设置命令行参数解析\r\n+    parser = argparse.ArgumentParser(description='Split a table in a SQLite database into multiple databases based on location.')\r\n+    parser.add_argument('--database', '-d', type=str, required=True, help='The path to the SQLite database.')\r\n+    parser.add_argument('--table', '-t', type=str, required=True, help='The table name in the database.')\r\n+    \r\n+    # 解析命令行参数\r\n+    args = parser.parse_args()\r\n+\r\n+    # 调用函数\r\n+    # 调用函数，传入数据库路径和原始表名\r\n+    split_table_into_multiple_dbs(args.database, args.table)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713521769447,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,76 @@\n+import sqlite3\r\n+import os\r\n+import shutil\r\n+import argparse\r\n+\r\n+def split_table_into_multiple_dbs(database_path, table_name):\r\n+    # 确保数据库文件存在\r\n+    if not os.path.exists(database_path):\r\n+        print(f\"Error: Database file '{database_path}' does not exist.\")\r\n+        return\r\n+\r\n+    # 连接到原始数据库\r\n+    conn = sqlite3.connect(database_path)\r\n+    cursor = conn.cursor()\r\n+\r\n+    # 使用方括号包裹表名以避免特殊字符问题\r\n+    wrapped_table_name = f'[{table_name}]'\r\n+    \r\n+    # 检查原始表是否存在\r\n+    cursor.execute(f\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (wrapped_table_name,))\r\n+    if cursor.fetchone() is None:\r\n+        print(f\"Error: Table '{table_name}' does not exist in the database.\")\r\n+        return\r\n+\r\n+    # 查询所有不同的location值\r\n+    cursor.execute(f\"SELECT DISTINCT location FROM {wrapped_table_name}\")\r\n+    locations = cursor.fetchall()\r\n+\r\n+    # 对每个location进行处理\r\n+    for location in locations:\r\n+        location = location[0]  # 获取元组中的location值\r\n+        file_name = os.path.basename(location)\r\n+        new_table_name = f\"{file_name}_table\"\r\n+\r\n+        # 尝试创建新表，如果已存在则跳过\r\n+        try:\r\n+            cursor.execute(f\"CREATE TABLE IF NOT EXISTS {new_table_name} AS SELECT * FROM {wrapped_table_name} WHERE location=?\", (location,))\r\n+        except sqlite3.OperationalError as e:\r\n+            print(f\"Error creating table {new_table_name}: {e}\")\r\n+            continue\r\n+\r\n+        # 创建新数据库文件\r\n+        new_db_path = os.path.join(location, 'yy_orgcodenote_my_database.db')\r\n+        if not os.path.exists(new_db_path):\r\n+            with open(new_db_path, 'wb') as f:\r\n+                pass  # 创建空文件\r\n+\r\n+        # 连接到新数据库\r\n+        new_conn = sqlite3.connect(new_db_path)\r\n+        new_cursor = new_conn.cursor()\r\n+\r\n+        # 删除新数据库中除新表以外的所有表\r\n+        new_cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE ? AND name NOT LIKE 'sqlite_sequence'\", (new_table_name,))\r\n+        tables_to_drop = new_cursor.fetchall()\r\n+        for table in tables_to_drop:\r\n+            new_cursor.execute(f\"DROP TABLE {table[0]}\")\r\n+\r\n+        # 提交更改并关闭新数据库连接\r\n+        new_conn.commit()\r\n+        new_conn.close()\r\n+\r\n+    # 关闭原始数据库连接\r\n+    conn.close()\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # 设置命令行参数解析\r\n+    parser = argparse.ArgumentParser(description='Split a table in a SQLite database into multiple databases based on location.')\r\n+    parser.add_argument('--database', '-d', type=str, required=True, help='The path to the SQLite database.')\r\n+    parser.add_argument('--table', '-t', type=str, required=True, help='The table name in the database.')\r\n+    \r\n+    # 解析命令行参数\r\n+    args = parser.parse_args()\r\n+\r\n+    # 调用函数\r\n+    # 调用函数，传入数据库路径和原始表名\r\n+    split_table_into_multiple_dbs(args.database, args.table)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713521775623,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,76 @@\n+import sqlite3\r\n+import os\r\n+import shutil\r\n+import argparse\r\n+\r\n+def split_table_into_multiple_dbs(database_path, table_name):\r\n+    # 确保数据库文件存在\r\n+    if not os.path.exists(database_path):\r\n+        print(f\"Error: Database file '{database_path}' does not exist.\")\r\n+        return\r\n+\r\n+    # 连接到原始数据库\r\n+    conn = sqlite3.connect(database_path)\r\n+    cursor = conn.cursor()\r\n+\r\n+    # 使用方括号包裹表名以避免特殊字符问题\r\n+    wrapped_table_name = f'[{table_name}]'\r\n+    \r\n+    # 检查原始表是否存在\r\n+    cursor.execute(f\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (wrapped_table_name,))\r\n+    if cursor.fetchone() is None:\r\n+        print(f\"Error: Table '{table_name}' does not exist in the database.\")\r\n+        return\r\n+\r\n+    # 查询所有不同的location值\r\n+    cursor.execute(f\"SELECT DISTINCT location FROM {wrapped_table_name}\")\r\n+    locations = cursor.fetchall()\r\n+\r\n+    # 对每个location进行处理\r\n+    for location in locations:\r\n+        location = location[0]  # 获取元组中的location值\r\n+        file_name = os.path.basename(location)\r\n+        new_table_name = f\"{file_name}_table\"\r\n+\r\n+        # 尝试创建新表，如果已存在则跳过\r\n+        try:\r\n+            cursor.execute(f\"CREATE TABLE IF NOT EXISTS {new_table_name} AS SELECT * FROM {wrapped_table_name} WHERE location=?\", (location,))\r\n+        except sqlite3.OperationalError as e:\r\n+            print(f\"Error creating table {new_table_name}: {e}\")\r\n+            continue\r\n+\r\n+        # 创建新数据库文件\r\n+        new_db_path = os.path.join(location, 'yy_orgcodenote_my_database.db')\r\n+        if not os.path.exists(new_db_path):\r\n+            with open(new_db_path, 'wb') as f:\r\n+                pass  # 创建空文件\r\n+\r\n+        # 连接到新数据库\r\n+        new_conn = sqlite3.connect(new_db_path)\r\n+        new_cursor = new_conn.cursor()\r\n+\r\n+        # 删除新数据库中除新表以外的所有表\r\n+        new_cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE ? AND name NOT LIKE 'sqlite_sequence'\", (new_table_name,))\r\n+        tables_to_drop = new_cursor.fetchall()\r\n+        for table in tables_to_drop:\r\n+            new_cursor.execute(f\"DROP TABLE {table[0]}\")\r\n+\r\n+        # 提交更改并关闭新数据库连接\r\n+        new_conn.commit()\r\n+        new_conn.close()\r\n+\r\n+    # 关闭原始数据库连接\r\n+    conn.close()\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # 设置命令行参数解析\r\n+    parser = argparse.ArgumentParser(description='Split a table in a SQLite database into multiple databases based on location.')\r\n+    parser.add_argument('--database', '-d', type=str, required=True, help='The path to the SQLite database.')\r\n+    parser.add_argument('--table', '-t', type=str, required=True, help='The table name in the database.')\r\n+    \r\n+    # 解析命令行参数\r\n+    args = parser.parse_args()\r\n+\r\n+    # 调用函数\r\n+    # 调用函数，传入数据库路径和原始表名\r\n+    split_table_into_multiple_dbs(args.database, args.table)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713521867595,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,379 +0,0 @@\n-import sqlite3\r\n-import os\r\n-import shutil\r\n-import argparse\r\n-\r\n-def split_table_into_multiple_dbs(database_path, table_name):\r\n-    # 确保数据库文件存在\r\n-    if not os.path.exists(database_path):\r\n-        print(f\"Error: Database file '{database_path}' does not exist.\")\r\n-        return\r\n-\r\n-    # 连接到原始数据库\r\n-    conn = sqlite3.connect(database_path)\r\n-    cursor = conn.cursor()\r\n-\r\n-    # 使用方括号包裹表名以避免特殊字符问题\r\n-    wrapped_table_name = f'[{table_name}]'\r\n-    \r\n-    # 检查原始表是否存在\r\n-    cursor.execute(f\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (wrapped_table_name,))\r\n-    if cursor.fetchone() is None:\r\n-        print(f\"Error: Table '{table_name}' does not exist in the database.\")\r\n-        return\r\n-\r\n-    # 查询所有不同的location值\r\n-    cursor.execute(f\"SELECT DISTINCT location FROM {wrapped_table_name}\")\r\n-    locations = cursor.fetchall()\r\n-\r\n-    # 对每个location进行处理\r\n-    for location in locations:\r\n-        location = location[0]  # 获取元组中的location值\r\n-        file_name = os.path.basename(location)\r\n-        new_table_name = f\"{file_name}_table\"\r\n-\r\n-        # 尝试创建新表，如果已存在则跳过\r\n-        try:\r\n-            cursor.execute(f\"CREATE TABLE IF NOT EXISTS {new_table_name} AS SELECT * FROM {wrapped_table_name} WHERE location=?\", (location,))\r\n-        except sqlite3.OperationalError as e:\r\n-            print(f\"Error creating table {new_table_name}: {e}\")\r\n-            continue\r\n-\r\n-        # 创建新数据库文件\r\n-        new_db_path = os.path.join(location, 'yy_orgcodenote_my_database.db')\r\n-        if not os.path.exists(new_db_path):\r\n-            with open(new_db_path, 'wb') as f:\r\n-                pass  # 创建空文件\r\n-\r\n-        # 连接到新数据库\r\n-        new_conn = sqlite3.connect(new_db_path)\r\n-        new_cursor = new_conn.cursor()\r\n-\r\n-        # 删除新数据库中除新表以外的所有表\r\n-        new_cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE ? AND name NOT LIKE 'sqlite_sequence'\", (new_table_name,))\r\n-        tables_to_drop = new_cursor.fetchall()\r\n-        for table in tables_to_drop:\r\n-            new_cursor.execute(f\"DROP TABLE {table[0]}\")\r\n-\r\n-        # 提交更改并关闭新数据库连接\r\n-        new_conn.commit()\r\n-        new_conn.close()\r\n-\r\n-    # 关闭原始数据库连接\r\n-    conn.close()\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # 设置命令行参数解析\r\n-    parser = argparse.ArgumentParser(description='Split a table in a SQLite database into multiple databases based on location.')\r\n-    parser.add_argument('--database', '-d', type=str, required=True, help='The path to the SQLite database.')\r\n-    parser.add_argument('--table', '-t', type=str, required=True, help='The table name in the database.')\r\n-    \r\n-    # 解析命令行参数\r\n-    args = parser.parse_args()\r\n-\r\n-    # 调用函数\r\n-    # 调用函数，传入数据库路径和原始表名\r\n-    split_table_into_multiple_dbs(args.database, args.table)\n-import sqlite3\r\n-import os\r\n-import shutil\r\n-import argparse\r\n-\r\n-def split_table_into_multiple_dbs(database_path, table_name):\r\n-    # 确保数据库文件存在\r\n-    if not os.path.exists(database_path):\r\n-        print(f\"Error: Database file '{database_path}' does not exist.\")\r\n-        return\r\n-\r\n-    # 连接到原始数据库\r\n-    conn = sqlite3.connect(database_path)\r\n-    cursor = conn.cursor()\r\n-\r\n-    # 使用方括号包裹表名以避免特殊字符问题\r\n-    wrapped_table_name = f'[{table_name}]'\r\n-    \r\n-    # 检查原始表是否存在\r\n-    cursor.execute(f\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (wrapped_table_name,))\r\n-    if cursor.fetchone() is None:\r\n-        print(f\"Error: Table '{table_name}' does not exist in the database.\")\r\n-        return\r\n-\r\n-    # 查询所有不同的location值\r\n-    cursor.execute(f\"SELECT DISTINCT location FROM {wrapped_table_name}\")\r\n-    locations = cursor.fetchall()\r\n-\r\n-    # 对每个location进行处理\r\n-    for location in locations:\r\n-        location = location[0]  # 获取元组中的location值\r\n-        file_name = os.path.basename(location)\r\n-        new_table_name = f\"{file_name}_table\"\r\n-\r\n-        # 尝试创建新表，如果已存在则跳过\r\n-        try:\r\n-            cursor.execute(f\"CREATE TABLE IF NOT EXISTS {new_table_name} AS SELECT * FROM {wrapped_table_name} WHERE location=?\", (location,))\r\n-        except sqlite3.OperationalError as e:\r\n-            print(f\"Error creating table {new_table_name}: {e}\")\r\n-            continue\r\n-\r\n-        # 创建新数据库文件\r\n-        new_db_path = os.path.join(location, 'yy_orgcodenote_my_database.db')\r\n-        if not os.path.exists(new_db_path):\r\n-            with open(new_db_path, 'wb') as f:\r\n-                pass  # 创建空文件\r\n-\r\n-        # 连接到新数据库\r\n-        new_conn = sqlite3.connect(new_db_path)\r\n-        new_cursor = new_conn.cursor()\r\n-\r\n-        # 删除新数据库中除新表以外的所有表\r\n-        new_cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE ? AND name NOT LIKE 'sqlite_sequence'\", (new_table_name,))\r\n-        tables_to_drop = new_cursor.fetchall()\r\n-        for table in tables_to_drop:\r\n-            new_cursor.execute(f\"DROP TABLE {table[0]}\")\r\n-\r\n-        # 提交更改并关闭新数据库连接\r\n-        new_conn.commit()\r\n-        new_conn.close()\r\n-\r\n-    # 关闭原始数据库连接\r\n-    conn.close()\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # 设置命令行参数解析\r\n-    parser = argparse.ArgumentParser(description='Split a table in a SQLite database into multiple databases based on location.')\r\n-    parser.add_argument('--database', '-d', type=str, required=True, help='The path to the SQLite database.')\r\n-    parser.add_argument('--table', '-t', type=str, required=True, help='The table name in the database.')\r\n-    \r\n-    # 解析命令行参数\r\n-    args = parser.parse_args()\r\n-\r\n-    # 调用函数\r\n-    # 调用函数，传入数据库路径和原始表名\r\n-    split_table_into_multiple_dbs(args.database, args.table)\n-import sqlite3\r\n-import os\r\n-import shutil\r\n-import argparse\r\n-\r\n-def split_table_into_multiple_dbs(database_path, table_name):\r\n-    # 确保数据库文件存在\r\n-    if not os.path.exists(database_path):\r\n-        print(f\"Error: Database file '{database_path}' does not exist.\")\r\n-        return\r\n-\r\n-    # 连接到原始数据库\r\n-    conn = sqlite3.connect(database_path)\r\n-    cursor = conn.cursor()\r\n-\r\n-    # 使用方括号包裹表名以避免特殊字符问题\r\n-    wrapped_table_name = f'[{table_name}]'\r\n-    \r\n-    # 检查原始表是否存在\r\n-    cursor.execute(f\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (wrapped_table_name,))\r\n-    if cursor.fetchone() is None:\r\n-        print(f\"Error: Table '{table_name}' does not exist in the database.\")\r\n-        return\r\n-\r\n-    # 查询所有不同的location值\r\n-    cursor.execute(f\"SELECT DISTINCT location FROM {wrapped_table_name}\")\r\n-    locations = cursor.fetchall()\r\n-\r\n-    # 对每个location进行处理\r\n-    for location in locations:\r\n-        location = location[0]  # 获取元组中的location值\r\n-        file_name = os.path.basename(location)\r\n-        new_table_name = f\"{file_name}_table\"\r\n-\r\n-        # 尝试创建新表，如果已存在则跳过\r\n-        try:\r\n-            cursor.execute(f\"CREATE TABLE IF NOT EXISTS {new_table_name} AS SELECT * FROM {wrapped_table_name} WHERE location=?\", (location,))\r\n-        except sqlite3.OperationalError as e:\r\n-            print(f\"Error creating table {new_table_name}: {e}\")\r\n-            continue\r\n-\r\n-        # 创建新数据库文件\r\n-        new_db_path = os.path.join(location, 'yy_orgcodenote_my_database.db')\r\n-        if not os.path.exists(new_db_path):\r\n-            with open(new_db_path, 'wb') as f:\r\n-                pass  # 创建空文件\r\n-\r\n-        # 连接到新数据库\r\n-        new_conn = sqlite3.connect(new_db_path)\r\n-        new_cursor = new_conn.cursor()\r\n-\r\n-        # 删除新数据库中除新表以外的所有表\r\n-        new_cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE ? AND name NOT LIKE 'sqlite_sequence'\", (new_table_name,))\r\n-        tables_to_drop = new_cursor.fetchall()\r\n-        for table in tables_to_drop:\r\n-            new_cursor.execute(f\"DROP TABLE {table[0]}\")\r\n-\r\n-        # 提交更改并关闭新数据库连接\r\n-        new_conn.commit()\r\n-        new_conn.close()\r\n-\r\n-    # 关闭原始数据库连接\r\n-    conn.close()\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # 设置命令行参数解析\r\n-    parser = argparse.ArgumentParser(description='Split a table in a SQLite database into multiple databases based on location.')\r\n-    parser.add_argument('--database', '-d', type=str, required=True, help='The path to the SQLite database.')\r\n-    parser.add_argument('--table', '-t', type=str, required=True, help='The table name in the database.')\r\n-    \r\n-    # 解析命令行参数\r\n-    args = parser.parse_args()\r\n-\r\n-    # 调用函数\r\n-    # 调用函数，传入数据库路径和原始表名\r\n-    split_table_into_multiple_dbs(args.database, args.table)\n-import sqlite3\r\n-import os\r\n-import shutil\r\n-import argparse\r\n-\r\n-def split_table_into_multiple_dbs(database_path, table_name):\r\n-    # 确保数据库文件存在\r\n-    if not os.path.exists(database_path):\r\n-        print(f\"Error: Database file '{database_path}' does not exist.\")\r\n-        return\r\n-\r\n-    # 连接到原始数据库\r\n-    conn = sqlite3.connect(database_path)\r\n-    cursor = conn.cursor()\r\n-\r\n-    # 使用方括号包裹表名以避免特殊字符问题\r\n-    wrapped_table_name = f'[{table_name}]'\r\n-    \r\n-    # 检查原始表是否存在\r\n-    cursor.execute(f\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (wrapped_table_name,))\r\n-    if cursor.fetchone() is None:\r\n-        print(f\"Error: Table '{table_name}' does not exist in the database.\")\r\n-        return\r\n-\r\n-    # 查询所有不同的location值\r\n-    cursor.execute(f\"SELECT DISTINCT location FROM {wrapped_table_name}\")\r\n-    locations = cursor.fetchall()\r\n-\r\n-    # 对每个location进行处理\r\n-    for location in locations:\r\n-        location = location[0]  # 获取元组中的location值\r\n-        file_name = os.path.basename(location)\r\n-        new_table_name = f\"{file_name}_table\"\r\n-\r\n-        # 尝试创建新表，如果已存在则跳过\r\n-        try:\r\n-            cursor.execute(f\"CREATE TABLE IF NOT EXISTS {new_table_name} AS SELECT * FROM {wrapped_table_name} WHERE location=?\", (location,))\r\n-        except sqlite3.OperationalError as e:\r\n-            print(f\"Error creating table {new_table_name}: {e}\")\r\n-            continue\r\n-\r\n-        # 创建新数据库文件\r\n-        new_db_path = os.path.join(location, 'yy_orgcodenote_my_database.db')\r\n-        if not os.path.exists(new_db_path):\r\n-            with open(new_db_path, 'wb') as f:\r\n-                pass  # 创建空文件\r\n-\r\n-        # 连接到新数据库\r\n-        new_conn = sqlite3.connect(new_db_path)\r\n-        new_cursor = new_conn.cursor()\r\n-\r\n-        # 删除新数据库中除新表以外的所有表\r\n-        new_cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE ? AND name NOT LIKE 'sqlite_sequence'\", (new_table_name,))\r\n-        tables_to_drop = new_cursor.fetchall()\r\n-        for table in tables_to_drop:\r\n-            new_cursor.execute(f\"DROP TABLE {table[0]}\")\r\n-\r\n-        # 提交更改并关闭新数据库连接\r\n-        new_conn.commit()\r\n-        new_conn.close()\r\n-\r\n-    # 关闭原始数据库连接\r\n-    conn.close()\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # 设置命令行参数解析\r\n-    parser = argparse.ArgumentParser(description='Split a table in a SQLite database into multiple databases based on location.')\r\n-    parser.add_argument('--database', '-d', type=str, required=True, help='The path to the SQLite database.')\r\n-    parser.add_argument('--table', '-t', type=str, required=True, help='The table name in the database.')\r\n-    \r\n-    # 解析命令行参数\r\n-    args = parser.parse_args()\r\n-\r\n-    # 调用函数\r\n-    #\r\n-    # 调用函数，传入数据库路径和原始表名\r\n-    split_table_into_multiple_dbs(args.database, args.table)\n-import sqlite3\r\n-import os\r\n-import shutil\r\n-import argparse\r\n-\r\n-def split_table_into_multiple_dbs(database_path, table_name):\r\n-    # 确保数据库文件存在\r\n-    if not os.path.exists(database_path):\r\n-        print(f\"Error: Database file '{database_path}' does not exist.\")\r\n-        return\r\n-\r\n-    # 连接到原始数据库\r\n-    conn = sqlite3.connect(database_path)\r\n-    cursor = conn.cursor()\r\n-\r\n-    # 使用方括号包裹表名以避免特殊字符问题\r\n-    wrapped_table_name = f'[{table_name}]'\r\n-    \r\n-    # 检查原始表是否存在\r\n-    cursor.execute(f\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (wrapped_table_name,))\r\n-    if cursor.fetchone() is None:\r\n-        print(f\"Error: Table '{table_name}' does not exist in the database.\")\r\n-        return\r\n-\r\n-    # 查询所有不同的location值\r\n-    cursor.execute(f\"SELECT DISTINCT location FROM {wrapped_table_name}\")\r\n-    locations = cursor.fetchall()\r\n-\r\n-    # 对每个location进行处理\r\n-    for location in locations:\r\n-        location = location[0]  # 获取元组中的location值\r\n-        file_name = os.path.basename(location)\r\n-        new_table_name = f\"{file_name}_table\"\r\n-\r\n-        # 尝试创建新表，如果已存在则跳过\r\n-        try:\r\n-            cursor.execute(f\"CREATE TABLE IF NOT EXISTS {new_table_name} AS SELECT * FROM {wrapped_table_name} WHERE location=?\", (location,))\r\n-        except sqlite3.OperationalError as e:\r\n-            print(f\"Error creating table {new_table_name}: {e}\")\r\n-            continue\r\n-\r\n-        # 创建新数据库文件\r\n-        new_db_path = os.path.join(location, 'yy_orgcodenote_my_database.db')\r\n-        if not os.path.exists(new_db_path):\r\n-            with open(new_db_path, 'wb') as f:\r\n-                pass  # 创建空文件\r\n-\r\n-        # 连接到新数据库\r\n-        new_conn = sqlite3.connect(new_db_path)\r\n-        new_cursor = new_conn.cursor()\r\n-\r\n-        # 删除新数据库中除新表以外的所有表\r\n-        new_cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE ? AND name NOT LIKE 'sqlite_sequence'\", (new_table_name,))\r\n-        tables_to_drop = new_cursor.fetchall()\r\n-        for table in tables_to_drop:\r\n-            new_cursor.execute(f\"DROP TABLE {table[0]}\")\r\n-\r\n-        # 提交更改并关闭新数据库连接\r\n-        new_conn.commit()\r\n-        new_conn.close()\r\n-\r\n-    # 关闭原始数据库连接\r\n-    conn.close()\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # 设置命令行参数解析\r\n-    parser = argparse.ArgumentParser(description='Split a table in a SQLite database into multiple databases based on location.')\r\n-    parser.add_argument('--database', '-d', type=str, required=True, help='The path to the SQLite database.')\r\n-    parser.add_argument('--table', '-t', type=str, required=True, help='The table name in the database.')\r\n-    \r\n-    # 解析命令行参数\r\n-    args = parser.parse_args()\r\n-\r\n-    # 调用函数\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713521875342,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,47 @@\n+\r\n+import sqlite3\r\n+import os\r\n+import argparse\r\n+\r\n+def merge_databases(main_db_path, db_paths):\r\n+    # 连接到主数据库\r\n+    conn = sqlite3.connect(main_db_path)\r\n+    cursor = conn.cursor()\r\n+\r\n+    # 创建主数据库（如果它不存在）\r\n+    if not os.path.exists(main_db_path):\r\n+        with open(main_db_path, 'wb') as f:\r\n+            pass  # 创建空文件\r\n+\r\n+    # 添加所有数据库路径\r\n+    for db_path in db_paths:\r\n+        cursor.execute(f\"ATTACH DATABASE '{db_path}' AS {os.path.basename(db_path)}\")\r\n+\r\n+    # 复制所有表到主数据库\r\n+    for db_name in cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\"):\r\n+        db_name = db_name[0]\r\n+        cursor.execute(f\"SELECT sql FROM sqlite_master WHERE type='table' AND name='{db_name}'\")\r\n+        table_sql = cursor.fetchone()[0]\r\n+        \r\n+        # 如果主数据库中没有这个表，则创建它\r\n+        if not cursor.execute(f\"SELECT name FROM sqlite_master WHERE type='table' AND name='{db_name}'\").fetchone():\r\n+            cursor.execute(f\"CREATE TABLE {db_name} AS {table_sql}\")\r\n+        else:\r\n+            # 如果主数据库中已经存在这个表，则合并数据\r\n+            cursor.execute(f\"INSERT INTO {db_name} SELECT * FROM {db_name}@{os.path.basename(db_path)}\")\r\n+\r\n+    # 提交更改并关闭连接\r\n+    conn.commit()\r\n+    conn.close()\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # 设置命令行参数解析\r\n+    parser = argparse.ArgumentParser(description='Merge multiple SQLite databases into one.')\r\n+    parser.add_argument('--main-db', '-m', type=str, required=True, help='The path to the main SQLite database.')\r\n+    parser.add_argument('--db-paths', '-p', nargs='+', type=str, required=True, help='The paths to the databases to be merged.')\r\n+    \r\n+    # 解析命令行参数\r\n+    args = parser.parse_args()\r\n+\r\n+    # 调用函数，传入主数据库路径和要合并的数据库路径\r\n+    merge_databases(args.main_db, args.db_paths)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713522003786,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,47 +0,0 @@\n-\r\n-import sqlite3\r\n-import os\r\n-import argparse\r\n-\r\n-def merge_databases(main_db_path, db_paths):\r\n-    # 连接到主数据库\r\n-    conn = sqlite3.connect(main_db_path)\r\n-    cursor = conn.cursor()\r\n-\r\n-    # 创建主数据库（如果它不存在）\r\n-    if not os.path.exists(main_db_path):\r\n-        with open(main_db_path, 'wb') as f:\r\n-            pass  # 创建空文件\r\n-\r\n-    # 添加所有数据库路径\r\n-    for db_path in db_paths:\r\n-        cursor.execute(f\"ATTACH DATABASE '{db_path}' AS {os.path.basename(db_path)}\")\r\n-\r\n-    # 复制所有表到主数据库\r\n-    for db_name in cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\"):\r\n-        db_name = db_name[0]\r\n-        cursor.execute(f\"SELECT sql FROM sqlite_master WHERE type='table' AND name='{db_name}'\")\r\n-        table_sql = cursor.fetchone()[0]\r\n-        \r\n-        # 如果主数据库中没有这个表，则创建它\r\n-        if not cursor.execute(f\"SELECT name FROM sqlite_master WHERE type='table' AND name='{db_name}'\").fetchone():\r\n-            cursor.execute(f\"CREATE TABLE {db_name} AS {table_sql}\")\r\n-        else:\r\n-            # 如果主数据库中已经存在这个表，则合并数据\r\n-            cursor.execute(f\"INSERT INTO {db_name} SELECT * FROM {db_name}@{os.path.basename(db_path)}\")\r\n-\r\n-    # 提交更改并关闭连接\r\n-    conn.commit()\r\n-    conn.close()\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # 设置命令行参数解析\r\n-    parser = argparse.ArgumentParser(description='Merge multiple SQLite databases into one.')\r\n-    parser.add_argument('--main-db', '-m', type=str, required=True, help='The path to the main SQLite database.')\r\n-    parser.add_argument('--db-paths', '-p', nargs='+', type=str, required=True, help='The paths to the databases to be merged.')\r\n-    \r\n-    # 解析命令行参数\r\n-    args = parser.parse_args()\r\n-\r\n-    # 调用函数，传入主数据库路径和要合并的数据库路径\r\n-    merge_databases(args.main_db, args.db_paths)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713522010788,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,42 @@\n+\r\n+import sqlite3\r\n+import os\r\n+import argparse\r\n+\r\n+def merge_databases(main_db_path, db_paths):\r\n+    # 连接到主数据库\r\n+    conn = sqlite3.connect(main_db_path)\r\n+    cursor = conn.cursor()\r\n+\r\n+    # 创建主数据库（如果它不存在）\r\n+    if not os.path.exists(main_db_path):\r\n+        with open(main_db_path, 'wb') as f:\r\n+            pass  # 创建空文件\r\n+\r\n+    # 添加所有数据库路径\r\n+    for db_path in db_paths:\r\n+        db_name = os.path.splitext(os.path.basename(db_path))[0]  # 移除文件扩展名\r\n+        cursor.execute(f\"ATTACH DATABASE '{db_path}' AS {db_name}\")\r\n+\r\n+    # 复制所有表到主数据库\r\n+    for db_name in cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\"):\r\n+        db_name = db_name[0]\r\n+        cursor.execute(f\"SELECT sql FROM sqlite_master WHERE type='table' AND name='{db_name}'\")\r\n+        table_sql = cursor.fetchone()[0]\r\n+        cursor.execute(f\"CREATE TABLE {db_name} AS {table_sql}\")\r\n+\r\n+    # 提交更改并关闭连接\r\n+    conn.commit()\r\n+    conn.close()\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # 设置命令行参数解析\r\n+    parser = argparse.ArgumentParser(description='Merge multiple SQLite databases into one.')\r\n+    parser.add_argument('--main-db', '-m', type=str, required=True, help='The path to the main SQLite database.')\r\n+    parser.add_argument('--db-paths', '-p', nargs='+', type=str, required=True, help='The paths to the databases to be merged.')\r\n+    \r\n+    # 解析命令行参数\r\n+    args = parser.parse_args()\r\n+\r\n+    # 调用函数，传入主数据库路径和要合并的数据库路径\r\n+    merge_databases(args.main_db, args.db_paths)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713522166083,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,41 +0,0 @@\n-import sqlite3\r\n-import os\r\n-import argparse\r\n-\r\n-def merge_databases(main_db_path, db_paths):\r\n-    # 连接到主数据库\r\n-    conn = sqlite3.connect(main_db_path)\r\n-    cursor = conn.cursor()\r\n-\r\n-    # 创建主数据库（如果它不存在）\r\n-    if not os.path.exists(main_db_path):\r\n-        with open(main_db_path, 'wb') as f:\r\n-            pass  # 创建空文件\r\n-\r\n-    # 添加所有数据库路径\r\n-    for db_path in db_paths:\r\n-        db_name = os.path.splitext(os.path.basename(db_path))[0]  # 移除文件扩展名\r\n-        cursor.execute(f\"ATTACH DATABASE '{db_path}' AS {db_name}\")\r\n-\r\n-    # 复制所有表到主数据库\r\n-    for db_name in cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\"):\r\n-        db_name = db_name[0]\r\n-        cursor.execute(f\"SELECT sql FROM sqlite_master WHERE type='table' AND name='{db_name}'\")\r\n-        table_sql = cursor.fetchone()[0]\r\n-        cursor.execute(f\"CREATE TABLE {db_name} AS {table_sql}\")\r\n-\r\n-    # 提交更改并关闭连接\r\n-    conn.commit()\r\n-    conn.close()\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # 设置命令行参数解析\r\n-    parser = argparse.ArgumentParser(description='Merge multiple SQLite databases into one.')\r\n-    parser.add_argument('--main-db', '-m', type=str, required=True, help='The path to the main SQLite database.')\r\n-    parser.add_argument('--db-paths', '-p', nargs='+', type=str, required=True, help='The paths to the databases to be merged.')\r\n-    \r\n-    # 解析命令行参数\r\n-    args = parser.parse_args()\r\n-\r\n-    # 调用函数，传入主数据库路径和要合并的数据库路径\r\n-    merge_databases(args.main_db, args.db_paths)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713522172364,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,1 +1,47 @@\n \r\n+import sqlite3\r\n+import os\r\n+import argparse\r\n+import re\r\n+\r\n+def merge_databases(main_db_path, db_paths):\r\n+    # 连接到主数据库\r\n+    conn = sqlite3.connect(main_db_path)\r\n+    cursor = conn.cursor()\r\n+\r\n+    # 创建主数据库（如果它不存在）\r\n+    if not os.path.exists(main_db_path):\r\n+        with open(main_db_path, 'wb') as f:\r\n+            pass  # 创建空文件\r\n+\r\n+    # 添加所有数据库路径\r\n+    for db_path in db_paths:\r\n+        db_name = os.path.splitext(os.path.basename(db_path))[0]  # 移除文件扩展名\r\n+        cursor.execute(f\"ATTACH DATABASE '{db_path}' AS {db_name}\")\r\n+\r\n+    # 复制所有表到主数据库\r\n+    for db_name in cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\"):\r\n+        db_name = db_name[0]\r\n+        cursor.execute(f\"SELECT sql FROM sqlite_master WHERE type='table' AND name='{db_name}'\")\r\n+        table_sql = cursor.fetchone()[0]\r\n+\r\n+        # 使用正则表达式添加引号到表名和列名\r\n+        table_sql = re.sub(r'(\\w+)', r'\"\\1\"', table_sql)\r\n+\r\n+        cursor.execute(f\"CREATE TABLE {db_name} AS {table_sql}\")\r\n+\r\n+    # 提交更改并关闭连接\r\n+    conn.commit()\r\n+    conn.close()\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # 设置命令行参数解析\r\n+    parser = argparse.ArgumentParser(description='Merge multiple SQLite databases into one.')\r\n+    parser.add_argument('--main-db', '-m', type=str, required=True, help='The path to the main SQLite database.')\r\n+    parser.add_argument('--db-paths', '-p', nargs='+', type=str, required=True, help='The paths to the databases to be merged.')\r\n+    \r\n+    # 解析命令行参数\r\n+    args = parser.parse_args()\r\n+\r\n+    # 调用函数，传入主数据库路径和要合并的数据库路径\r\n+    merge_databases(args.main_db, args.db_paths)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713522196995,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,46 @@\n+import sqlite3\r\n+import os\r\n+import argparse\r\n+import re\r\n+\r\n+def merge_databases(main_db_path, db_paths):\r\n+    # 连接到主数据库\r\n+    conn = sqlite3.connect(main_db_path)\r\n+    cursor = conn.cursor()\r\n+\r\n+    # 创建主数据库（如果它不存在）\r\n+    if not os.path.exists(main_db_path):\r\n+        with open(main_db_path, 'wb') as f:\r\n+            pass  # 创建空文件\r\n+\r\n+    # 添加所有数据库路径\r\n+    for db_path in db_paths:\r\n+        db_name = os.path.splitext(os.path.basename(db_path))[0]  # 移除文件扩展名\r\n+        cursor.execute(f\"ATTACH DATABASE '{db_path}' AS {db_name}\")\r\n+\r\n+    # 复制所有表到主数据库\r\n+    for db_name in cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\"):\r\n+        db_name = db_name[0]\r\n+        cursor.execute(f\"SELECT sql FROM sqlite_master WHERE type='table' AND name='{db_name}'\")\r\n+        table_sql = cursor.fetchone()[0]\r\n+\r\n+        # 使用正则表达式添加引号到表名和列名\r\n+        table_sql = re.sub(r'(\\w+)', r'\"\\1\"', table_sql)\r\n+\r\n+        cursor.execute(f\"CREATE TABLE {db_name} AS {table_sql}\")\r\n+\r\n+    # 提交更改并关闭连接\r\n+    conn.commit()\r\n+    conn.close()\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # 设置命令行参数解析\r\n+    parser = argparse.ArgumentParser(description='Merge multiple SQLite databases into one.')\r\n+    parser.add_argument('--main-db', '-m', type=str, required=True, help='The path to the main SQLite database.')\r\n+    parser.add_argument('--db-paths', '-p', nargs='+', type=str, required=True, help='The paths to the databases to be merged.')\r\n+    \r\n+    # 解析命令行参数\r\n+    args = parser.parse_args()\r\n+\r\n+    # 调用函数，传入主数据库路径和要合并的数据库路径\r\n+    merge_databases(args.main_db, args.db_paths)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713522306319,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,93 +0,0 @@\n-import sqlite3\r\n-import os\r\n-import argparse\r\n-import re\r\n-\r\n-def merge_databases(main_db_path, db_paths):\r\n-    # 连接到主数据库\r\n-    conn = sqlite3.connect(main_db_path)\r\n-    cursor = conn.cursor()\r\n-\r\n-    # 创建主数据库（如果它不存在）\r\n-    if not os.path.exists(main_db_path):\r\n-        with open(main_db_path, 'wb') as f:\r\n-            pass  # 创建空文件\r\n-\r\n-    # 添加所有数据库路径\r\n-    for db_path in db_paths:\r\n-        db_name = os.path.splitext(os.path.basename(db_path))[0]  # 移除文件扩展名\r\n-        cursor.execute(f\"ATTACH DATABASE '{db_path}' AS {db_name}\")\r\n-\r\n-    # 复制所有表到主数据库\r\n-    for db_name in cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\"):\r\n-        db_name = db_name[0]\r\n-        cursor.execute(f\"SELECT sql FROM sqlite_master WHERE type='table' AND name='{db_name}'\")\r\n-        table_sql = cursor.fetchone()[0]\r\n-\r\n-        # 使用正则表达式添加引号到表名和列名\r\n-        table_sql = re.sub(r'(\\w+)', r'\"\\1\"', table_sql)\r\n-\r\n-        cursor.execute(f\"CREATE TABLE {db_name} AS {table_sql}\")\r\n-\r\n-    # 提交更改并关闭连接\r\n-    conn.commit()\r\n-    conn.close()\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # 设置命令行参数解析\r\n-    parser = argparse.ArgumentParser(description='Merge multiple SQLite databases into one.')\r\n-    parser.add_argument('--main-db', '-m', type=str, required=True, help='The path to the main SQLite database.')\r\n-    parser.add_argument('--db-paths', '-p', nargs='+', type=str, required=True, help='The paths to the databases to be merged.')\r\n-    \r\n-    # 解析命令行参数\r\n-    args = parser.parse_args()\r\n-\r\n-    # 调用函数，传入主数据库路径和要合并的数据库路径\r\n-    merge_databases(args.main_db, args.db_paths)\n-\r\n-import sqlite3\r\n-import os\r\n-import argparse\r\n-import re\r\n-\r\n-def merge_databases(main_db_path, db_paths):\r\n-    # 连接到主数据库\r\n-    conn = sqlite3.connect(main_db_path)\r\n-    cursor = conn.cursor()\r\n-\r\n-    # 创建主数据库（如果它不存在）\r\n-    if not os.path.exists(main_db_path):\r\n-        with open(main_db_path, 'wb') as f:\r\n-            pass  # 创建空文件\r\n-\r\n-    # 添加所有数据库路径\r\n-    for db_path in db_paths:\r\n-        db_name = os.path.splitext(os.path.basename(db_path))[0]  # 移除文件扩展名\r\n-        cursor.execute(f\"ATTACH DATABASE '{db_path}' AS {db_name}\")\r\n-\r\n-    # 复制所有表到主数据库\r\n-    for db_name in cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\"):\r\n-        db_name = db_name[0]\r\n-        cursor.execute(f\"SELECT sql FROM sqlite_master WHERE type='table' AND name='{db_name}'\")\r\n-        table_sql = cursor.fetchone()[0]\r\n-\r\n-        # 使用正则表达式添加引号到表名和列名\r\n-        table_sql = re.sub(r'(\\w+)', r'\"\\1\"', table_sql)\r\n-\r\n-        cursor.execute(f\"CREATE TABLE {db_name} AS {table_sql}\")\r\n-\r\n-    # 提交更改并关闭连接\r\n-    conn.commit()\r\n-    conn.close()\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # 设置命令行参数解析\r\n-    parser = argparse.ArgumentParser(description='Merge multiple SQLite databases into one.')\r\n-    parser.add_argument('--main-db', '-m', type=str, required=True, help='The path to the main SQLite database.')\r\n-    parser.add_argument('--db-paths', '-p', nargs='+', type=str, required=True, help='The paths to the databases to be merged.')\r\n-    \r\n-    # 解析命令行参数\r\n-    args = parser.parse_args()\r\n-\r\n-    # 调用函数，传入主数据库路径和要合并的数据库路径\r\n-    merge_databases(args.main_db, args.db_paths)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713522316257,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,48 @@\n+\r\n+import sqlite3\r\n+import os\r\n+import argparse\r\n+import re\r\n+\r\n+def merge_databases(main_db_path, db_paths):\r\n+    # 连接到主数据库\r\n+    conn = sqlite3.connect(main_db_path)\r\n+    cursor = conn.cursor()\r\n+\r\n+    # 创建主数据库（如果它不存在）\r\n+    if not os.path.exists(main_db_path):\r\n+        with open(main_db_path, 'wb') as f:\r\n+            pass  # 创建空文件\r\n+\r\n+    # 添加所有数据库路径\r\n+    for db_path in db_paths:\r\n+        db_name = os.path.splitext(os.path.basename(db_path))[0]  # 移除文件扩展名\r\n+        cursor.execute(f\"ATTACH DATABASE '{db_path}' AS {db_name}\")\r\n+\r\n+    # 复制所有表到主数据库\r\n+    for db_name in cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\"):\r\n+        db_name = db_name[0]\r\n+        cursor.execute(f\"SELECT sql FROM sqlite_master WHERE type='table' AND name=?\", (db_name,))\r\n+        table_sql = cursor.fetchone()[0]\r\n+\r\n+        # 打印 table_sql 以检查其内容\r\n+        print(f\"Table SQL: {table_sql}\")\r\n+\r\n+        # 使用参数化查询来创建表\r\n+        cursor.execute(table_sql)\r\n+\r\n+    # 提交更改并关闭连接\r\n+    conn.commit()\r\n+    conn.close()\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # 设置命令行参数解析\r\n+    parser = argparse.ArgumentParser(description='Merge multiple SQLite databases into one.')\r\n+    parser.add_argument('--main-db', '-m', type=str, required=True, help='The path to the main SQLite database.')\r\n+    parser.add_argument('--db-paths', '-p', nargs='+', type=str, required=True, help='The paths to the databases to be merged.')\r\n+    \r\n+    # 解析命令行参数\r\n+    args = parser.parse_args()\r\n+\r\n+    # 调用函数，传入主数据库路径和要合并的数据库路径\r\n+    merge_databases(args.main_db, args.db_paths)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713522438663,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,48 +0,0 @@\n-\r\n-import sqlite3\r\n-import os\r\n-import argparse\r\n-import re\r\n-\r\n-def merge_databases(main_db_path, db_paths):\r\n-    # 连接到主数据库\r\n-    conn = sqlite3.connect(main_db_path)\r\n-    cursor = conn.cursor()\r\n-\r\n-    # 创建主数据库（如果它不存在）\r\n-    if not os.path.exists(main_db_path):\r\n-        with open(main_db_path, 'wb') as f:\r\n-            pass  # 创建空文件\r\n-\r\n-    # 添加所有数据库路径\r\n-    for db_path in db_paths:\r\n-        db_name = os.path.splitext(os.path.basename(db_path))[0]  # 移除文件扩展名\r\n-        cursor.execute(f\"ATTACH DATABASE '{db_path}' AS {db_name}\")\r\n-\r\n-    # 复制所有表到主数据库\r\n-    for db_name in cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\"):\r\n-        db_name = db_name[0]\r\n-        cursor.execute(f\"SELECT sql FROM sqlite_master WHERE type='table' AND name=?\", (db_name,))\r\n-        table_sql = cursor.fetchone()[0]\r\n-\r\n-        # 打印 table_sql 以检查其内容\r\n-        print(f\"Table SQL: {table_sql}\")\r\n-\r\n-        # 使用参数化查询来创建表\r\n-        cursor.execute(table_sql)\r\n-\r\n-    # 提交更改并关闭连接\r\n-    conn.commit()\r\n-    conn.close()\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # 设置命令行参数解析\r\n-    parser = argparse.ArgumentParser(description='Merge multiple SQLite databases into one.')\r\n-    parser.add_argument('--main-db', '-m', type=str, required=True, help='The path to the main SQLite database.')\r\n-    parser.add_argument('--db-paths', '-p', nargs='+', type=str, required=True, help='The paths to the databases to be merged.')\r\n-    \r\n-    # 解析命令行参数\r\n-    args = parser.parse_args()\r\n-\r\n-    # 调用函数，传入主数据库路径和要合并的数据库路径\r\n-    merge_databases(args.main_db, args.db_paths)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713522448138,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,51 @@\n+\r\n+import sqlite3\r\n+import os\r\n+import argparse\r\n+\r\n+def merge_databases(main_db_path, db_paths):\r\n+    # 连接到主数据库\r\n+    conn = sqlite3.connect(main_db_path)\r\n+    cursor = conn.cursor()\r\n+\r\n+    # 创建主数据库（如果它不存在）\r\n+    if not os.path.exists(main_db_path):\r\n+        with open(main_db_path, 'wb') as f:\r\n+            pass  # 创建空文件\r\n+\r\n+    # 添加所有数据库路径\r\n+    for db_path in db_paths:\r\n+        db_name = os.path.splitext(os.path.basename(db_path))[0]  # 移除文件扩展名\r\n+        cursor.execute(f\"ATTACH DATABASE '{db_path}' AS {db_name}\")\r\n+\r\n+    # 处理所有表\r\n+    for db_name in cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\"):\r\n+        table_name = db_name[0]\r\n+        # 检查表是否在主数据库中已经存在\r\n+        cursor.execute(f\"SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name='{table_name}'\")\r\n+        if cursor.fetchone()[0] > 0:\r\n+            # 表已存在，执行合并操作\r\n+            cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name[0]}.{table_name}\")\r\n+        else:\r\n+            # 表不存在，从源数据库复制表结构到主数据库\r\n+            cursor.execute(f\"SELECT sql FROM {db_name[0]}.sqlite_master WHERE type='table' AND name='{table_name}'\")\r\n+            create_table_sql = cursor.fetchone()[0]\r\n+            cursor.execute(create_table_sql)\r\n+            # 复制数据\r\n+            cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name[0]}.{table_name}\")\r\n+\r\n+    # 提交更改并关闭连接\r\n+    conn.commit()\r\n+    conn.close()\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # 设置命令行参数解析\r\n+    parser = argparse.ArgumentParser(description='Merge multiple SQLite databases into one.')\r\n+    parser.add_argument('--main-db', '-m', type=str, required=True, help='The path to the main SQLite database.')\r\n+    parser.add_argument('--db-paths', '-p', nargs='+', type=str, required=True, help='The paths to the databases to be merged.')\r\n+    \r\n+    # 解析命令行参数\r\n+    args = parser.parse_args()\r\n+\r\n+    # 调用函数，传入主数据库路径和要合并的数据库路径\r\n+    merge_databases(args.main_db, args.db_paths)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713522720323,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,51 +0,0 @@\n-\r\n-import sqlite3\r\n-import os\r\n-import argparse\r\n-\r\n-def merge_databases(main_db_path, db_paths):\r\n-    # 连接到主数据库\r\n-    conn = sqlite3.connect(main_db_path)\r\n-    cursor = conn.cursor()\r\n-\r\n-    # 创建主数据库（如果它不存在）\r\n-    if not os.path.exists(main_db_path):\r\n-        with open(main_db_path, 'wb') as f:\r\n-            pass  # 创建空文件\r\n-\r\n-    # 添加所有数据库路径\r\n-    for db_path in db_paths:\r\n-        db_name = os.path.splitext(os.path.basename(db_path))[0]  # 移除文件扩展名\r\n-        cursor.execute(f\"ATTACH DATABASE '{db_path}' AS {db_name}\")\r\n-\r\n-    # 处理所有表\r\n-    for db_name in cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\"):\r\n-        table_name = db_name[0]\r\n-        # 检查表是否在主数据库中已经存在\r\n-        cursor.execute(f\"SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name='{table_name}'\")\r\n-        if cursor.fetchone()[0] > 0:\r\n-            # 表已存在，执行合并操作\r\n-            cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name[0]}.{table_name}\")\r\n-        else:\r\n-            # 表不存在，从源数据库复制表结构到主数据库\r\n-            cursor.execute(f\"SELECT sql FROM {db_name[0]}.sqlite_master WHERE type='table' AND name='{table_name}'\")\r\n-            create_table_sql = cursor.fetchone()[0]\r\n-            cursor.execute(create_table_sql)\r\n-            # 复制数据\r\n-            cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name[0]}.{table_name}\")\r\n-\r\n-    # 提交更改并关闭连接\r\n-    conn.commit()\r\n-    conn.close()\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # 设置命令行参数解析\r\n-    parser = argparse.ArgumentParser(description='Merge multiple SQLite databases into one.')\r\n-    parser.add_argument('--main-db', '-m', type=str, required=True, help='The path to the main SQLite database.')\r\n-    parser.add_argument('--db-paths', '-p', nargs='+', type=str, required=True, help='The paths to the databases to be merged.')\r\n-    \r\n-    # 解析命令行参数\r\n-    args = parser.parse_args()\r\n-\r\n-    # 调用函数，传入主数据库路径和要合并的数据库路径\r\n-    merge_databases(args.main_db, args.db_paths)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713522728970,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,51 @@\n+\r\n+import sqlite3\r\n+import os\r\n+import argparse\r\n+\r\n+def merge_databases(main_db_path, db_paths):\r\n+    # 连接到主数据库\r\n+    conn = sqlite3.connect(main_db_path)\r\n+    cursor = conn.cursor()\r\n+\r\n+    # 创建主数据库（如果它不存在）\r\n+    if not os.path.exists(main_db_path):\r\n+        with open(main_db_path, 'wb') as f:\r\n+            pass  # 创建空文件\r\n+\r\n+    # 添加所有数据库路径\r\n+    for db_path in db_paths:\r\n+        db_name = os.path.splitext(os.path.basename(db_path))[0]  # 移除文件扩展名\r\n+        cursor.execute(f\"ATTACH DATABASE '{db_path}' AS {db_name}\")\r\n+\r\n+    # 处理所有表\r\n+    for db_name in cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\"):\r\n+        table_name = db_name[0]\r\n+        # 检查表是否在主数据库中已经存在\r\n+        cursor.execute(f\"SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\r\n+        if cursor.fetchone()[0] > 0:\r\n+            # 表已存在，执行合并操作\r\n+            cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name}.{table_name}\")\r\n+        else:\r\n+            # 表不存在，从源数据库复制表结构到主数据库\r\n+            cursor.execute(f\"SELECT sql FROM {db_name}.sqlite_master WHERE type='table' AND name=?\", (table_name,))\r\n+            create_table_sql = cursor.fetchone()[0]\r\n+            cursor.execute(create_table_sql)\r\n+            # 复制数据\r\n+            cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name}.{table_name}\")\r\n+\r\n+    # 提交更改并关闭连接\r\n+    conn.commit()\r\n+    conn.close()\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # 设置命令行参数解析\r\n+    parser = argparse.ArgumentParser(description='Merge multiple SQLite databases into one.')\r\n+    parser.add_argument('--main-db', '-m', type=str, required=True, help='The path to the main SQLite database.')\r\n+    parser.add_argument('--db-paths', '-p', nargs='+', type=str, required=True, help='The paths to the databases to be merged.')\r\n+    \r\n+    # 解析命令行参数\r\n+    args = parser.parse_args()\r\n+\r\n+    # 调用函数，传入主数据库路径和要合并的数据库路径\r\n+    merge_databases(args.main_db, args.db_paths)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713522886407,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,67 @@\n+\r\n+import sqlite3\r\n+import os\r\n+import argparse\r\n+\r\n+def merge_databases(main_db_path, db_paths):\r\n+    # 连接到主数据库\r\n+    conn = sqlite3.connect(main_db_path)\r\n+    cursor = conn.cursor()\r\n+\r\n+    # 创建主数据库（如果它不存在）\r\n+    if not os.path.exists(main_db_path):\r\n+        with open(main_db_path, 'wb') as f:\r\n+            pass  # 创建空文件\r\n+\r\n+    # 添加所有数据库路径\r\n+    for db_path in db_paths:\r\n+        db_name = os.path.splitext(os.path.basename(db_path))[0]  # 移除文件扩展名\r\n+        cursor.execute(f\"ATTACH DATABASE '{db_path}' AS {db_name}\")\r\n+\r\n+    # 处理所有表\r\n+    for db_name in cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\"):\r\n+        table_name = db_name[0]\r\n+        # 检查表是否在主数据库中已经存在\r\n+        cursor.execute(f\"SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\r\n+        if cursor.fetchone()[0] > 0:\r\n+            # 表已存在，执行合并操作\r\n+            cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name}.{table_name}\")\r\n+        else:\r\n+            # 表不存在，从源数据库复制表结构到主数据库\r\n+            cursor.execute(f\"SELECT sql FROM {db_name}.sqlite_master WHERE type='table' AND name=?\", (table_name,))\r\n+            create_table_sql = cursor.fetchone()[0]\r\n+            cursor.execute(create_table_sql)\r\n+            # 复制数据\r\n+            cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name}.{table_name}\")\r\n+\r\n+# ...\r\n+    for db_name in cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\"):\r\n+        table_name = db_name[0]\r\n+        # 检查表是否存在于主数据库中\r\n+        cursor.execute(f\"SELECT COUNT(*) FROM main.{table_name}\")\r\n+        if cursor.fetchone()[0] > 0:\r\n+            # 表已存在，执行合并操作\r\n+            cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name[0]}\")\r\n+        else:\r\n+            # 表不存在，从源数据库复制表结构到主数据库\r\n+            cursor.execute(f\"SELECT sql FROM sqlite_master WHERE type='table' AND name='{db_name[0]}'\")\r\n+            create_table_sql = cursor.fetchone()[0]\r\n+            cursor.execute(create_table_sql)\r\n+            # 复制数据\r\n+            cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name[0]}\")\r\n+# ...\r\n+    # 提交更改并关闭连接\r\n+    conn.commit()\r\n+    conn.close()\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # 设置命令行参数解析\r\n+    parser = argparse.ArgumentParser(description='Merge multiple SQLite databases into one.')\r\n+    parser.add_argument('--main-db', '-m', type=str, required=True, help='The path to the main SQLite database.')\r\n+    parser.add_argument('--db-paths', '-p', nargs='+', type=str, required=True, help='The paths to the databases to be merged.')\r\n+    \r\n+    # 解析命令行参数\r\n+    args = parser.parse_args()\r\n+\r\n+    # 调用函数，传入主数据库路径和要合并的数据库路径\r\n+    merge_databases(args.main_db, args.db_paths)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713522893193,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,65 @@\n+\r\n+import sqlite3\r\n+import os\r\n+import argparse\r\n+\r\n+def merge_databases(main_db_path, db_paths):\r\n+    # 连接到主数据库\r\n+    conn = sqlite3.connect(main_db_path)\r\n+    cursor = conn.cursor()\r\n+\r\n+    # 创建主数据库（如果它不存在）\r\n+    if not os.path.exists(main_db_path):\r\n+        with open(main_db_path, 'wb') as f:\r\n+            pass  # 创建空文件\r\n+\r\n+    # 添加所有数据库路径\r\n+    for db_path in db_paths:\r\n+        db_name = os.path.splitext(os.path.basename(db_path))[0]  # 移除文件扩展名\r\n+        cursor.execute(f\"ATTACH DATABASE '{db_path}' AS {db_name}\")\r\n+\r\n+    # 处理所有表\r\n+    for db_name in cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\"):\r\n+        table_name = db_name[0]\r\n+        # 检查表是否在主数据库中已经存在\r\n+        cursor.execute(f\"SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\r\n+        if cursor.fetchone()[0] > 0:\r\n+            # 表已存在，执行合并操作\r\n+            cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name}.{table_name}\")\r\n+        else:\r\n+            # 表不存在，从源数据库复制表结构到主数据库\r\n+            cursor.execute(f\"SELECT sql FROM {db_name}.sqlite_master WHERE type='table' AND name=?\", (table_name,))\r\n+            create_table_sql = cursor.fetchone()[0]\r\n+            cursor.execute(create_table_sql)\r\n+            # 复制数据\r\n+            cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name}.{table_name}\")\r\n+\r\n+    for db_name in cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\"):\r\n+        table_name = db_name[0]\r\n+        # 检查表是否存在于主数据库中\r\n+        cursor.execute(f\"SELECT COUNT(*) FROM main.{table_name}\")\r\n+        if cursor.fetchone()[0] > 0:\r\n+            # 表已存在，执行合并操作\r\n+            cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name[0]}\")\r\n+        else:\r\n+            # 表不存在，从源数据库复制表结构到主数据库\r\n+            cursor.execute(f\"SELECT sql FROM sqlite_master WHERE type='table' AND name='{db_name[0]}'\")\r\n+            create_table_sql = cursor.fetchone()[0]\r\n+            cursor.execute(create_table_sql)\r\n+            # 复制数据\r\n+            cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name[0]}\")\r\n+    # 提交更改并关闭连接\r\n+    conn.commit()\r\n+    conn.close()\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # 设置命令行参数解析\r\n+    parser = argparse.ArgumentParser(description='Merge multiple SQLite databases into one.')\r\n+    parser.add_argument('--main-db', '-m', type=str, required=True, help='The path to the main SQLite database.')\r\n+    parser.add_argument('--db-paths', '-p', nargs='+', type=str, required=True, help='The paths to the databases to be merged.')\r\n+    \r\n+    # 解析命令行参数\r\n+    args = parser.parse_args()\r\n+\r\n+    # 调用函数，传入主数据库路径和要合并的数据库路径\r\n+    merge_databases(args.main_db, args.db_paths)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713522898827,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,51 @@\n+\r\n+import sqlite3\r\n+import os\r\n+import argparse\r\n+\r\n+def merge_databases(main_db_path, db_paths):\r\n+    # 连接到主数据库\r\n+    conn = sqlite3.connect(main_db_path)\r\n+    cursor = conn.cursor()\r\n+\r\n+    # 创建主数据库（如果它不存在）\r\n+    if not os.path.exists(main_db_path):\r\n+        with open(main_db_path, 'wb') as f:\r\n+            pass  # 创建空文件\r\n+\r\n+    # 添加所有数据库路径\r\n+    for db_path in db_paths:\r\n+        db_name = os.path.splitext(os.path.basename(db_path))[0]  # 移除文件扩展名\r\n+        cursor.execute(f\"ATTACH DATABASE '{db_path}' AS {db_name}\")\r\n+\r\n+  \r\n+\r\n+    for db_name in cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\"):\r\n+        table_name = db_name[0]\r\n+        # 检查表是否存在于主数据库中\r\n+        cursor.execute(f\"SELECT COUNT(*) FROM main.{table_name}\")\r\n+        if cursor.fetchone()[0] > 0:\r\n+            # 表已存在，执行合并操作\r\n+            cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name[0]}\")\r\n+        else:\r\n+            # 表不存在，从源数据库复制表结构到主数据库\r\n+            cursor.execute(f\"SELECT sql FROM sqlite_master WHERE type='table' AND name='{db_name[0]}'\")\r\n+            create_table_sql = cursor.fetchone()[0]\r\n+            cursor.execute(create_table_sql)\r\n+            # 复制数据\r\n+            cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name[0]}\")\r\n+    # 提交更改并关闭连接\r\n+    conn.commit()\r\n+    conn.close()\r\n+\r\n+if __name__ == \"__main__\":\r\n+    # 设置命令行参数解析\r\n+    parser = argparse.ArgumentParser(description='Merge multiple SQLite databases into one.')\r\n+    parser.add_argument('--main-db', '-m', type=str, required=True, help='The path to the main SQLite database.')\r\n+    parser.add_argument('--db-paths', '-p', nargs='+', type=str, required=True, help='The paths to the databases to be merged.')\r\n+    \r\n+    # 解析命令行参数\r\n+    args = parser.parse_args()\r\n+\r\n+    # 调用函数，传入主数据库路径和要合并的数据库路径\r\n+    merge_databases(args.main_db, args.db_paths)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713523132764,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,140 +17,24 @@\n     for db_path in db_paths:\r\n         db_name = os.path.splitext(os.path.basename(db_path))[0]  # 移除文件扩展名\r\n         cursor.execute(f\"ATTACH DATABASE '{db_path}' AS {db_name}\")\r\n \r\n-  \r\n \r\n+# ...\r\n     for db_name in cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\"):\r\n         table_name = db_name[0]\r\n         # 检查表是否存在于主数据库中\r\n         cursor.execute(f\"SELECT COUNT(*) FROM main.{table_name}\")\r\n         if cursor.fetchone()[0] > 0:\r\n             # 表已存在，执行合并操作\r\n-            cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name[0]}\")\r\n+            cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name[0]} AS source_table\")\r\n         else:\r\n             # 表不存在，从源数据库复制表结构到主数据库\r\n             cursor.execute(f\"SELECT sql FROM sqlite_master WHERE type='table' AND name='{db_name[0]}'\")\r\n             create_table_sql = cursor.fetchone()[0]\r\n             cursor.execute(create_table_sql)\r\n             # 复制数据\r\n-            cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name[0]}\")\r\n-    # 提交更改并关闭连接\r\n-    conn.commit()\r\n-    conn.close()\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # 设置命令行参数解析\r\n-    parser = argparse.ArgumentParser(description='Merge multiple SQLite databases into one.')\r\n-    parser.add_argument('--main-db', '-m', type=str, required=True, help='The path to the main SQLite database.')\r\n-    parser.add_argument('--db-paths', '-p', nargs='+', type=str, required=True, help='The paths to the databases to be merged.')\r\n-    \r\n-    # 解析命令行参数\r\n-    args = parser.parse_args()\r\n-\r\n-    # 调用函数，传入主数据库路径和要合并的数据库路径\r\n-    merge_databases(args.main_db, args.db_paths)\n-\r\n-import sqlite3\r\n-import os\r\n-import argparse\r\n-\r\n-def merge_databases(main_db_path, db_paths):\r\n-    # 连接到主数据库\r\n-    conn = sqlite3.connect(main_db_path)\r\n-    cursor = conn.cursor()\r\n-\r\n-    # 创建主数据库（如果它不存在）\r\n-    if not os.path.exists(main_db_path):\r\n-        with open(main_db_path, 'wb') as f:\r\n-            pass  # 创建空文件\r\n-\r\n-    # 添加所有数据库路径\r\n-    for db_path in db_paths:\r\n-        db_name = os.path.splitext(os.path.basename(db_path))[0]  # 移除文件扩展名\r\n-        cursor.execute(f\"ATTACH DATABASE '{db_path}' AS {db_name}\")\r\n-\r\n-    # 处理所有表\r\n-    for db_name in cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\"):\r\n-        table_name = db_name[0]\r\n-        # 检查表是否在主数据库中已经存在\r\n-        cursor.execute(f\"SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\r\n-        if cursor.fetchone()[0] > 0:\r\n-            # 表已存在，执行合并操作\r\n-            cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name}.{table_name}\")\r\n-        else:\r\n-            # 表不存在，从源数据库复制表结构到主数据库\r\n-            cursor.execute(f\"SELECT sql FROM {db_name}.sqlite_master WHERE type='table' AND name=?\", (table_name,))\r\n-            create_table_sql = cursor.fetchone()[0]\r\n-            cursor.execute(create_table_sql)\r\n-            # 复制数据\r\n-            cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name}.{table_name}\")\r\n-\r\n-    for db_name in cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\"):\r\n-        table_name = db_name[0]\r\n-        # 检查表是否存在于主数据库中\r\n-        cursor.execute(f\"SELECT COUNT(*) FROM main.{table_name}\")\r\n-        if cursor.fetchone()[0] > 0:\r\n-            # 表已存在，执行合并操作\r\n-            cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name[0]}\")\r\n-        else:\r\n-            # 表不存在，从源数据库复制表结构到主数据库\r\n-            cursor.execute(f\"SELECT sql FROM sqlite_master WHERE type='table' AND name='{db_name[0]}'\")\r\n-            create_table_sql = cursor.fetchone()[0]\r\n-            cursor.execute(create_table_sql)\r\n-            # 复制数据\r\n-            cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name[0]}\")\r\n-    # 提交更改并关闭连接\r\n-    conn.commit()\r\n-    conn.close()\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # 设置命令行参数解析\r\n-    parser = argparse.ArgumentParser(description='Merge multiple SQLite databases into one.')\r\n-    parser.add_argument('--main-db', '-m', type=str, required=True, help='The path to the main SQLite database.')\r\n-    parser.add_argument('--db-paths', '-p', nargs='+', type=str, required=True, help='The paths to the databases to be merged.')\r\n-    \r\n-    # 解析命令行参数\r\n-    args = parser.parse_args()\r\n-\r\n-    # 调用函数，传入主数据库路径和要合并的数据库路径\r\n-    merge_databases(args.main_db, args.db_paths)\n-\r\n-import sqlite3\r\n-import os\r\n-import argparse\r\n-\r\n-def merge_databases(main_db_path, db_paths):\r\n-    # 连接到主数据库\r\n-    conn = sqlite3.connect(main_db_path)\r\n-    cursor = conn.cursor()\r\n-\r\n-    # 创建主数据库（如果它不存在）\r\n-    if not os.path.exists(main_db_path):\r\n-        with open(main_db_path, 'wb') as f:\r\n-            pass  # 创建空文件\r\n-\r\n-    # 添加所有数据库路径\r\n-    for db_path in db_paths:\r\n-        db_name = os.path.splitext(os.path.basename(db_path))[0]  # 移除文件扩展名\r\n-        cursor.execute(f\"ATTACH DATABASE '{db_path}' AS {db_name}\")\r\n-\r\n-    # 处理所有表\r\n-    for db_name in cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\"):\r\n-        table_name = db_name[0]\r\n-        # 检查表是否在主数据库中已经存在\r\n-        cursor.execute(f\"SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\r\n-        if cursor.fetchone()[0] > 0:\r\n-            # 表已存在，执行合并操作\r\n-            cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name}.{table_name}\")\r\n-        else:\r\n-            # 表不存在，从源数据库复制表结构到主数据库\r\n-            cursor.execute(f\"SELECT sql FROM {db_name}.sqlite_master WHERE type='table' AND name=?\", (table_name,))\r\n-            create_table_sql = cursor.fetchone()[0]\r\n-            cursor.execute(create_table_sql)\r\n-            # 复制数据\r\n-            cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name}.{table_name}\")\r\n-\r\n+            cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name[0]} AS source_table\")\r\n # ...\r\n     for db_name in cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\"):\r\n         table_name = db_name[0]\r\n         # 检查表是否存在于主数据库中\r\n@@ -164,9 +48,8 @@\n             create_table_sql = cursor.fetchone()[0]\r\n             cursor.execute(create_table_sql)\r\n             # 复制数据\r\n             cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name[0]}\")\r\n-# ...\r\n     # 提交更改并关闭连接\r\n     conn.commit()\r\n     conn.close()\r\n \r\n@@ -179,56 +62,5 @@\n     # 解析命令行参数\r\n     args = parser.parse_args()\r\n \r\n     # 调用函数，传入主数据库路径和要合并的数据库路径\r\n-    merge_databases(args.main_db, args.db_paths)\n-\r\n-import sqlite3\r\n-import os\r\n-import argparse\r\n-\r\n-def merge_databases(main_db_path, db_paths):\r\n-    # 连接到主数据库\r\n-    conn = sqlite3.connect(main_db_path)\r\n-    cursor = conn.cursor()\r\n-\r\n-    # 创建主数据库（如果它不存在）\r\n-    if not os.path.exists(main_db_path):\r\n-        with open(main_db_path, 'wb') as f:\r\n-            pass  # 创建空文件\r\n-\r\n-    # 添加所有数据库路径\r\n-    for db_path in db_paths:\r\n-        db_name = os.path.splitext(os.path.basename(db_path))[0]  # 移除文件扩展名\r\n-        cursor.execute(f\"ATTACH DATABASE '{db_path}' AS {db_name}\")\r\n-\r\n-    # 处理所有表\r\n-    for db_name in cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\"):\r\n-        table_name = db_name[0]\r\n-        # 检查表是否在主数据库中已经存在\r\n-        cursor.execute(f\"SELECT COUNT(*) FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\r\n-        if cursor.fetchone()[0] > 0:\r\n-            # 表已存在，执行合并操作\r\n-            cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name}.{table_name}\")\r\n-        else:\r\n-            # 表不存在，从源数据库复制表结构到主数据库\r\n-            cursor.execute(f\"SELECT sql FROM {db_name}.sqlite_master WHERE type='table' AND name=?\", (table_name,))\r\n-            create_table_sql = cursor.fetchone()[0]\r\n-            cursor.execute(create_table_sql)\r\n-            # 复制数据\r\n-            cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name}.{table_name}\")\r\n-\r\n-    # 提交更改并关闭连接\r\n-    conn.commit()\r\n-    conn.close()\r\n-\r\n-if __name__ == \"__main__\":\r\n-    # 设置命令行参数解析\r\n-    parser = argparse.ArgumentParser(description='Merge multiple SQLite databases into one.')\r\n-    parser.add_argument('--main-db', '-m', type=str, required=True, help='The path to the main SQLite database.')\r\n-    parser.add_argument('--db-paths', '-p', nargs='+', type=str, required=True, help='The paths to the databases to be merged.')\r\n-    \r\n-    # 解析命令行参数\r\n-    args = parser.parse_args()\r\n-\r\n-    # 调用函数，传入主数据库路径和要合并的数据库路径\r\n     merge_databases(args.main_db, args.db_paths)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1713523145199,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,22 +32,9 @@\n             create_table_sql = cursor.fetchone()[0]\r\n             cursor.execute(create_table_sql)\r\n             # 复制数据\r\n             cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name[0]} AS source_table\")\r\n-    for db_name in cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\"):\r\n-        table_name = db_name[0]\r\n-        # 检查表是否存在于主数据库中\r\n-        cursor.execute(f\"SELECT COUNT(*) FROM main.{table_name}\")\r\n-        if cursor.fetchone()[0] > 0:\r\n-            # 表已存在，执行合并操作\r\n-            cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name[0]}\")\r\n-        else:\r\n-            # 表不存在，从源数据库复制表结构到主数据库\r\n-            cursor.execute(f\"SELECT sql FROM sqlite_master WHERE type='table' AND name='{db_name[0]}'\")\r\n-            create_table_sql = cursor.fetchone()[0]\r\n-            cursor.execute(create_table_sql)\r\n-            # 复制数据\r\n-            cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name[0]}\")\r\n+ \r\n     # 提交更改并关闭连接\r\n     conn.commit()\r\n     conn.close()\r\n \r\n"
                },
                {
                    "date": 1713523158834,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,8 +32,9 @@\n             create_table_sql = cursor.fetchone()[0]\r\n             cursor.execute(create_table_sql)\r\n             # 复制数据\r\n             cursor.execute(f\"INSERT INTO main.{table_name} SELECT * FROM {db_name[0]} AS source_table\")\r\n+\r\n     # 提交更改并关闭连接\r\n     conn.commit()\r\n     conn.close()\r\n \r\n"
                }
            ],
            "date": 1713518183172,
            "name": "Commit-0",
            "content": "\r\nimport sqlite3\r\nimport os\r\nimport argparse\r\n\r\ndef merge_databases(main_db_path, db_paths):\r\n    # 连接到主数据库\r\n    conn = sqlite3.connect(main_db_path)\r\n    cursor = conn.cursor()\r\n\r\n    # 创建主数据库（如果它不存在）\r\n    if not os.path.exists(main_db_path):\r\n        with open(main_db_path, 'wb') as f:\r\n            pass  # 创建空文件\r\n\r\n    # 添加所有数据库路径\r\n    for db_path in db_paths:\r\n        cursor.execute(f\"ATTACH DATABASE '{db_path}' AS {os.path.basename(db_path)}\")\r\n\r\n    # 提交更改并关闭连接\r\n    conn.commit()\r\n    conn.close()\r\n\r\nif __name__ == \"__main__\":\r\n    # 设置命令行参数解析\r\n    parser = argparse.ArgumentParser(description='Merge multiple SQLite databases into one.')\r\n    parser.add_argument('--main-db', '-m', type=str, required=True, help='The path to the main SQLite database.')\r\n    parser.add_argument('--db-paths', '-p', nargs='+', type=str, required=True, help='The paths to the databases to be merged.')\r\n    \r\n    # 解析命令行参数\r\n    args = parser.parse_args()\r\n\r\n    # 调用函数，传入主数据库路径和要合并的数据库路径\r\n    merge_databases(args.main_db, args.db_paths)"
        }
    ]
}